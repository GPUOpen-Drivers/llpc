; This test checks that no random extra bytes are generated after the relocations
; in the relocation section (`.rel.text`). To check that, we extract the offsets of
; the relocation section and the following section from the elf and subtract
; them. Here we write 4 16-bit relocations, so the expected value should be
; around 0x40 (64 dec) (depending on section alignment).
; RUN: lgc -mcpu=gfx1030 -extract=2 -o %t.fs.elf %s
; RUN: lgc -mcpu=gfx1030 -extract=3 -other=%t.fs.elf -o %t.vs.elf %s
; RUN: lgc -mcpu=gfx1030 -extract=1 -l %s -o %t.pipe.elf %t.vs.elf %t.fs.elf
;
; RUN: llvm-readelf %t.pipe.elf --section-headers --elf-output-style=LLVM | FileCheck %s --match-full-lines
;
; CHECK-LABEL: Name: .rel.text ({{[0-9]+}})
; CHECK:       Offset: 0x[[#%X,OFFSET1:]]
; CHECK-LABEL: Name: .rodata.cst32 ({{[0-9]+}})
; CHECK:       Offset: 0x[[#OFFSET1 + 64]]
; CHECK-LABEL: Name: .note.GNU-stack ({{[0-9]+}})

; ----------------------------------------------------------------------
; Extract 1: The reduced pipeline state for the link.

target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
target triple = "amdgcn--amdpal"

; Metadata does not include user data nodes, as that is not needed for a link when the
; shaders were compiled with user data nodes.
!lgc.options = !{!0}
!lgc.options.FS = !{!1}
!lgc.options.VS = !{!4}
!lgc.color.export.formats = !{!18}
!lgc.vertex.inputs = !{!19, !20}
!lgc.input.assembly.state = !{!2}
!lgc.rasterizer.state = !{!21}

!0 = !{i32 -794094415, i32 0, i32 1583596299, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 1}
!1 = !{i32 -1843601953, i32 337452067, i32 -1234379640, i32 1173800166}
!2 = !{i32 2}
!4 = !{i32 -225903757, i32 -647980161, i32 1491774676, i32 -114025882}
!18 = !{i32 10}
!19 = !{i32 0, i32 0, i32 0, i32 0, i32 13, i32 7, i32 -1}
!20 = !{i32 1, i32 0, i32 24, i32 0, i32 11, i32 7, i32 -1}
!21 = !{i32 0, i32 0, i32 0, i32 1}
!22 = !{i32 0}

; ----------------------------------------------------------------------
; Extract 2: The fragment shader and pipeline state relevant to it.

target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
target triple = "amdgcn--amdpal"

%types.ResRet.f32.1 = type { float, float, float, float, i32 }

@table = internal unnamed_addr addrspace(4) constant [4 x <2 x float>] [<2 x float><float 1.125, float 1.25>, <2 x float><float 1.375, float 1.5>, <2 x float><float 1.625, float 1.75>, <2 x float><float 1.875, float 2.0>]

define dllexport void @lgc.shader.FS.main() !lgc.shaderstage !20 {
entry:
  %SV_Target = alloca <4 x float>, align 16, addrspace(5)
  %TEXCOORD = call <2 x float> (...) @lgc.create.read.generic.input.v2f32(i32 1, i32 0, i32 0, i32 1, i32 16, i32 poison)

  %posx = extractelement <2 x float> %TEXCOORD, i32 0
  %posxi = fptoui float %posx to i32
  %mod = urem i32 %posxi, 4
  %tableptr = getelementptr [4 x <2 x float>], [4 x <2 x float>] addrspace(4)* @table, i32 0, i32 %mod
  %adj = load <2 x float>, <2 x float> addrspace(4)* %tableptr
  %texcoordadj = fadd <2 x float> %TEXCOORD, %adj

  %0 = extractelement <2 x float> %texcoordadj, i32 0
  %1 = extractelement <2 x float> %texcoordadj, i32 1
  %2 = call <8 x i32> addrspace(4)* (...) @lgc.create.get.desc.ptr.p4v8i32(i32 1, i32 0, i32 0, i32 1)
  %3 = load <8 x i32>, <8 x i32> addrspace(4)* %2, align 32
  %4 = call <4 x i32> addrspace(4)* (...) @lgc.create.get.desc.ptr.p4v4i32(i32 2, i32 0, i32 0, i32 2)
  %5 = load <4 x i32>, <4 x i32> addrspace(4)* %4, align 16
  %6 = insertelement <2 x float> undef, float %0, i64 0
  %7 = insertelement <2 x float> %6, float %1, i64 1
  %8 = call <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 0, <8 x i32> %3, <4 x i32> %5, i32 1, <2 x float> %7)
  %9 = extractelement <4 x float> %8, i64 0
  %10 = insertvalue %types.ResRet.f32.1 undef, float %9, 0
  %11 = extractelement <4 x float> %8, i64 1
  %12 = insertvalue %types.ResRet.f32.1 %10, float %11, 1
  %13 = extractelement <4 x float> %8, i64 2
  %14 = insertvalue %types.ResRet.f32.1 %12, float %13, 2
  %15 = extractelement <4 x float> %8, i64 3
  %16 = insertvalue %types.ResRet.f32.1 %14, float %15, 3
  %17 = extractvalue %types.ResRet.f32.1 %16, 0
  %18 = load <4 x float>, <4 x float> addrspace(5)* %SV_Target, align 16
  %19 = insertelement <4 x float> %18, float %17, i8 0
  store <4 x float> %19, <4 x float> addrspace(5)* %SV_Target, align 16
  %20 = load <4 x float>, <4 x float> addrspace(5)* %SV_Target, align 16
  %21 = insertelement <4 x float> %20, float %17, i8 1
  store <4 x float> %21, <4 x float> addrspace(5)* %SV_Target, align 16
  %22 = load <4 x float>, <4 x float> addrspace(5)* %SV_Target, align 16
  %23 = insertelement <4 x float> %22, float %17, i8 2
  store <4 x float> %23, <4 x float> addrspace(5)* %SV_Target, align 16
  %24 = load <4 x float>, <4 x float> addrspace(5)* %SV_Target, align 16
  %25 = insertelement <4 x float> %24, float 1.000000e+00, i8 3
  store <4 x float> %25, <4 x float> addrspace(5)* %SV_Target, align 16
  %26 = load <4 x float>, <4 x float> addrspace(5)* %SV_Target, align 16
  call void (...) @lgc.create.write.generic.output(<4 x float> %26, i32 0, i32 0, i32 0, i32 1, i32 0, i32 undef)
  ret void
}

; Function Attrs: nounwind readonly willreturn
declare <2 x float> @lgc.create.read.generic.input.v2f32(...) #3

; Function Attrs: nounwind readnone
declare <8 x i32> addrspace(4)* @lgc.create.get.desc.ptr.p4v8i32(...) #1

; Function Attrs: nounwind readnone
declare <4 x i32> addrspace(4)* @lgc.create.get.desc.ptr.p4v4i32(...) #1

; Function Attrs: nounwind readonly willreturn
declare <4 x float> @lgc.create.image.sample.v4f32(...) #3

; Function Attrs: nounwind
declare void @lgc.create.write.generic.output(...) #2

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly willreturn }

; Metadata only includes parts that are relevant to the FS.
!lgc.unlinked = !{!2} ; !2 is 2, which is PipelineLink::PartPipeline
!lgc.options = !{!3}
!lgc.options.FS = !{!4}
!lgc.user.data.nodes = !{!10, !11, !14}
!lgc.color.export.formats = !{!19}

!2 = !{i32 2}
!3 = !{i32 -794094415, i32 0, i32 1583596299, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 1}
!4 = !{i32 -1843601953, i32 337452067, i32 -1234379640, i32 1173800166}
!10 = !{!"DescriptorTableVaPtr", i32 0, i32 0, i32 11, i32 1, i32 1}
!11 = !{!"DescriptorResource", i32 1, i32 0, i32 0, i32 80, i32 0, i32 1, i32 8}
!14 = !{!"DescriptorSampler", i32 2, i32 0, i32 -1, i32 4, i32 0, i32 2, i32 4, i32 12288, i32 117436416, i32 1750073344, i32 -2147483648}
!19 = !{i32 10}
!20 = !{i32 6}

; ----------------------------------------------------------------------
; Extract 3: The vertex shader and pipeline state relevant to it.

target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
target triple = "amdgcn--amdpal"

@table = internal unnamed_addr addrspace(4) constant [4 x <2 x float>] [<2 x float><float 0.125, float 0.25>, <2 x float><float 0.375, float 0.5>, <2 x float><float 0.625, float 0.75>, <2 x float><float 0.875, float 1.0>]

define dllexport void @lgc.shader.VS.main() !lgc.shaderstage !22 {
entry:
  %TEXCOORD1 = alloca <2 x float>, align 8, addrspace(5)
  %TEXCOORD = call <2 x float> (...) @lgc.create.read.generic.input.v2f32(i32 1, i32 0, i32 0, i32 1, i32 16, i32 poison)
  %SV_Position = alloca <4 x float>, align 16, addrspace(5)
  %POSITION = call <3 x float> (...) @lgc.create.read.generic.input.v3f32(i32 0, i32 0, i32 0, i32 1, i32 16, i32 poison)

  %posx = extractelement <3 x float> %POSITION, i32 0
  %posxi = fptoui float %posx to i32
  %mod = urem i32 %posxi, 4
  %tableptr = getelementptr [4 x <2 x float>], [4 x <2 x float>] addrspace(4)* @table, i32 0, i32 %mod
  %adj = load <2 x float>, <2 x float> addrspace(4)* %tableptr
  %texcoordadj = fadd <2 x float> %TEXCOORD, %adj

  %0 = extractelement <3 x float> %POSITION, i32 0
  %1 = extractelement <3 x float> %POSITION, i32 1
  %2 = extractelement <3 x float> %POSITION, i32 2
  %3 = load <4 x float>, <4 x float> addrspace(5)* %SV_Position, align 16
  %4 = insertelement <4 x float> %3, float %0, i8 0
  store <4 x float> %4, <4 x float> addrspace(5)* %SV_Position, align 16
  %5 = load <4 x float>, <4 x float> addrspace(5)* %SV_Position, align 16
  %6 = insertelement <4 x float> %5, float %1, i8 1
  store <4 x float> %6, <4 x float> addrspace(5)* %SV_Position, align 16
  %7 = load <4 x float>, <4 x float> addrspace(5)* %SV_Position, align 16
  %8 = insertelement <4 x float> %7, float %2, i8 2
  store <4 x float> %8, <4 x float> addrspace(5)* %SV_Position, align 16
  %9 = load <4 x float>, <4 x float> addrspace(5)* %SV_Position, align 16
  %10 = insertelement <4 x float> %9, float 1.000000e+00, i8 3
  store <4 x float> %10, <4 x float> addrspace(5)* %SV_Position, align 16
  %11 = extractelement <2 x float> %texcoordadj, i32 0
  %12 = extractelement <2 x float> %texcoordadj, i32 1
  %13 = load <2 x float>, <2 x float> addrspace(5)* %TEXCOORD1, align 8
  %14 = insertelement <2 x float> %13, float %11, i8 0
  store <2 x float> %14, <2 x float> addrspace(5)* %TEXCOORD1, align 8
  %15 = load <2 x float>, <2 x float> addrspace(5)* %TEXCOORD1, align 8
  %16 = insertelement <2 x float> %15, float %12, i8 1
  store <2 x float> %16, <2 x float> addrspace(5)* %TEXCOORD1, align 8
  %17 = load <4 x float>, <4 x float> addrspace(5)* %SV_Position, align 16
  call void (...) @lgc.create.write.builtin.output(<4 x float> %17, i32 0, i32 0, i32 poison, i32 poison)
  %18 = load <2 x float>, <2 x float> addrspace(5)* %TEXCOORD1, align 8
  call void (...) @lgc.create.write.generic.output(<2 x float> %18, i32 1, i32 0, i32 0, i32 1, i32 0, i32 poison)
  ret void
}

; Function Attrs: nounwind readonly willreturn
declare <3 x float> @lgc.create.read.generic.input.v3f32(...) #2

; Function Attrs: nounwind
declare void @lgc.create.write.builtin.output(...) #1

; Function Attrs: nounwind readonly willreturn
declare <2 x float> @lgc.create.read.generic.input.v2f32(...) #2

; Function Attrs: nounwind
declare void @lgc.create.write.generic.output(...) #1

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind }
attributes #2 = { nounwind readonly willreturn }

; Metadata only includes parts that are relevant to the VS.
!lgc.unlinked = !{!2} ; !2 is 2, which is PipelineLink::PartPipeline
!lgc.options = !{!3}
!lgc.options.VS = !{!4}
!lgc.user.data.nodes = !{!10, !11, !14}
!lgc.vertex.inputs = !{!19, !20}
!lgc.input.assembly.state = !{!2}
!lgc.rasterizer.state = !{!21}

!2 = !{i32 2}
!3 = !{i32 -794094415, i32 0, i32 1583596299, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 1}
!4 = !{i32 -225903757, i32 -647980161, i32 1491774676, i32 -114025882}
!10 = !{!"DescriptorTableVaPtr", i32 0, i32 0, i32 11, i32 1, i32 1}
!11 = !{!"DescriptorResource", i32 1, i32 0, i32 0, i32 80, i32 0, i32 1, i32 8}
!14 = !{!"DescriptorSampler", i32 2, i32 0, i32 -1, i32 4, i32 0, i32 2, i32 4, i32 12288, i32 117436416, i32 1750073344, i32 -2147483648}
!19 = !{i32 0, i32 0, i32 0, i32 0, i32 13, i32 7, i32 -1}
!20 = !{i32 1, i32 0, i32 24, i32 0, i32 11, i32 7, i32 -1}
!21 = !{i32 0, i32 0, i32 0, i32 1}
!22 = !{i32 1}
