; RUN: lgc -mcpu=gfx900 -stop-after=lgc-bounds-check-memory - <%s | FileCheck %s

; lgc code generated with amdllpc llpc/test/shaderdb/OpLoad_StackBoundsCheck_struct.pipe -emit-lgc

; ModuleID = 'lgcPipeline'
source_filename = "lgcPipeline"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--amdpal"

; Function Attrs: nounwind
define spir_func void @lgc.shader.VS.main() local_unnamed_addr #0 !spirv.ExecutionModel !10 !lgc.shaderstage !10 {
.entry:
  %0 = call <4 x float> (...) @lgc.create.read.generic.input.v4f32(i32 0, i32 0, i32 0, i32 0, i32 0, i32 undef)
  call void (...) @lgc.create.write.builtin.output(<4 x float> %0, i32 0, i32 0, i32 undef, i32 undef)
  call void (...) @lgc.create.write.builtin.output(float undef, i32 1, i32 0, i32 undef, i32 undef)
  call void (...) @lgc.create.write.builtin.output([1 x float] undef, i32 3, i32 4096, i32 undef, i32 undef)
  call void (...) @lgc.create.write.builtin.output([1 x float] undef, i32 4, i32 4096, i32 undef, i32 undef)
  call void (...) @lgc.create.write.generic.output(<4 x float> %0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 undef)
  ret void
}

; Function Attrs: nounwind readonly
declare <4 x float> @lgc.create.read.generic.input.v4f32(...) local_unnamed_addr #1

; Function Attrs: nounwind
declare void @lgc.create.write.builtin.output(...) local_unnamed_addr #0

; Function Attrs: nounwind
declare void @lgc.create.write.generic.output(...) local_unnamed_addr #0

; Function Attrs: nounwind
define spir_func void @lgc.shader.FS.main() local_unnamed_addr #0 !spirv.ExecutionModel !11 !lgc.shaderstage !11 {
.entry:
  %0 = call <4 x float> (...) @lgc.create.read.generic.input.v4f32(i32 0, i32 0, i32 0, i32 0, i32 16, i32 undef)
  %1 = alloca [16 x [16 x { <3 x float>, float, <3 x float> }]], align 16, addrspace(5)
  br label %2

2:                                                ; preds = %18, %.entry
  %.0 = phi i32 [ 0, %.entry ], [ %19, %18 ]
  %3 = icmp slt i32 %.0, 16
  br i1 %3, label %4, label %20

4:                                                ; preds = %2, %6
  %.013 = phi i32 [ %17, %6 ], [ 0, %2 ]
  %5 = icmp slt i32 %.013, 16
  br i1 %5, label %6, label %18

6:                                                ; preds = %4
  %__llpc_input_proxy_.0.vec.extract = extractelement <4 x float> %0, i32 0
  %7 = sitofp i32 %.0 to float
  %8 = fadd reassoc nnan nsz arcp contract afn float %__llpc_input_proxy_.0.vec.extract, %7
  %9 = fadd reassoc nnan nsz arcp contract afn float %8, 5.000000e+00
  %10 = insertelement <3 x float> undef, float %9, i32 0
  %11 = shufflevector <3 x float> %10, <3 x float> undef, <3 x i32> zeroinitializer
  %__llpc_input_proxy_.4.vec.extract = extractelement <4 x float> %0, i32 1
  %12 = fadd reassoc nnan nsz arcp contract afn float %__llpc_input_proxy_.4.vec.extract, %7
  %13 = fadd reassoc nnan nsz arcp contract afn float %12, 2.000000e+00
  %14 = getelementptr [16 x [16 x { <3 x float>, float, <3 x float> }]], [16 x [16 x { <3 x float>, float, <3 x float> }]] addrspace(5)* %1, i32 0, i32 %.0, i32 %.013, i32 0
  store <3 x float> %11, <3 x float> addrspace(5)* %14, align 16
  %15 = getelementptr [16 x [16 x { <3 x float>, float, <3 x float> }]], [16 x [16 x { <3 x float>, float, <3 x float> }]] addrspace(5)* %1, i32 0, i32 %.0, i32 %.013, i32 1
  store float %13, float addrspace(5)* %15, align 16
  %16 = getelementptr [16 x [16 x { <3 x float>, float, <3 x float> }]], [16 x [16 x { <3 x float>, float, <3 x float> }]] addrspace(5)* %1, i32 0, i32 %.0, i32 %.013, i32 2
  store <3 x float> %11, <3 x float> addrspace(5)* %16, align 16
  %17 = add i32 %.013, 1
  br label %4, !llvm.loop !12

18:                                               ; preds = %4
  %19 = add i32 %.0, 1
  br label %2, !llvm.loop !13

20:                                               ; preds = %2
  %__llpc_input_proxy_.4.vec.extract12 = extractelement <4 x float> %0, i32 1

; CHECK:      %[[MUL:[0-9]+]] = fmul reassoc nnan nsz arcp contract afn float %[[#]], 2.550000e+02
; CHECK-NEXT: %[[TSI:[0-9]+]] = fptosi float %[[MUL]] to i32
; CHECK-NEXT: %[[CMP:[0-9]+]] = icmp ult i32 %[[TSI]], -16
; CHECK-NEXT: %.inv = xor i1 %[[CMP]], true
; CHECK-NEXT: %[[IFC:[0-9]+]] = call { i1, i64 } @llvm.amdgcn.if.i64(i1 %.inv)
; CHECK-NEXT: %[[IF0:[0-9]+]] = extractvalue { i1, i64 } %[[IFC]], 0
; CHECK-NEXT: %[[IF1:[0-9]+]] = extractvalue { i1, i64 } %[[IFC]], 1
; CHECK-NEXT: br i1 %[[IF0]], label %[[LB0:[0-9]+]], label %[[LB1:[0-9]+]]

  %21 = fmul reassoc nnan nsz arcp contract afn float %__llpc_input_proxy_.4.vec.extract12, 2.550000e+02
  %22 = fptosi float %21 to i32

; CHECK:      [[LB0]]:
; CHECK-NEXT: %[[ADD:[0-9]+]] = add nsw i32 %[[TSI]], 16
; CHECK-NEXT: %[[PTR:[0-9]+]] = getelementptr [16 x [16 x { <3 x float>, float, <3 x float> }]], [16 x [16 x { <3 x float>, float, <3 x float> }]] addrspace(5)* %[[#]], i32 0, i32 %[[ADD]], i32 1, i32 2, i32 1
; CHECK-NEXT: %[[VAL:[0-9]+]] = load float, float addrspace(5)* %[[PTR]], align 4
; CHECK-NEXT: br label %[[LB1]]

  %23 = add i32 %22, 16
  %24 = getelementptr [16 x [16 x { <3 x float>, float, <3 x float> }]], [16 x [16 x { <3 x float>, float, <3 x float> }]] addrspace(5)* %1, i32 0, i32 %23, i32 1, i32 2, i32 1
  %25 = load float, float addrspace(5)* %24, align 4

; CHECK:      [[LB1]]:
; CHECK-NEXT: %[[PHI:[0-9]+]] = phi float [ 0.000000e+00, %.entry ], [ %[[VAL]], %[[LB0]] ]
; CHECK-NEXT: call void @llvm.amdgcn.end.cf.i64(i64 %[[IF1]])
; CHECK-NEXT: %[[CVT:[0-9]+]] = call <2 x half> @llvm.amdgcn.cvt.pkrtz(float %[[PHI]], float 0.000000e+00) #1
; CHECK-NEXT: call void @llvm.amdgcn.exp.compr.v2f16(i32 immarg 0, i32 immarg 15, <2 x half> %[[CVT]], <2 x half> <half 0xH0000, half 0xH3C00>, i1 immarg true, i1 immarg true) #2
; CHECK-NEXT: ret void

  %26 = insertelement <4 x float> <float undef, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00>, float %25, i32 0
  call void (...) @lgc.create.write.generic.output(<4 x float> %26, i32 0, i32 0, i32 0, i32 0, i32 0, i32 undef)
  ret void
}

attributes #0 = { nounwind }
attributes #1 = { nounwind readonly }

!lgc.options = !{!0}
!lgc.options.VS = !{!1}
!lgc.options.FS = !{!2}
!lgc.vertex.inputs = !{!3, !4, !5}
!lgc.color.export.formats = !{!6}
!lgc.input.assembly.state = !{!7}
!lgc.viewport.state = !{!8}
!lgc.rasterizer.state = !{!9}

!0 = !{i32 1472734038, i32 951774412, i32 -1164039144, i32 -357869313, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 2, i32 0, i32 0, i32 1}
!1 = !{i32 2059820324, i32 -2055480947, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 64, i32 0, i32 0, i32 3}
!2 = !{i32 272488772, i32 -330177307, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 0, i32 64, i32 0, i32 0, i32 3}
!3 = !{i32 0, i32 0, i32 0, i32 16, i32 14, i32 7, i32 -1}
!4 = !{i32 1, i32 0, i32 0, i32 16, i32 11, i32 7, i32 -1}
!5 = !{i32 2, i32 0, i32 0, i32 16, i32 11, i32 7, i32 -1}
!6 = !{i32 10, i32 0, i32 0, i32 1}
!7 = !{i32 10, i32 3}
!8 = !{i32 1}
!9 = !{i32 0, i32 0, i32 0, i32 1}
!10 = !{i32 0}
!11 = !{i32 4}
!12 = distinct !{!12}
!13 = distinct !{!13}
