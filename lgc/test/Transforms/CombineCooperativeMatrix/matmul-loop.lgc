; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool lgc --version 2
; RUN: lgc -o - -passes='require<lgc-pipeline-state>,function(lgc-combine-cooperative-matrix)' %s | FileCheck --check-prefixes=CHECK %s

define void @matmul_f16(ptr %ptr) {
; CHECK-LABEL: define void @matmul_f16
; CHECK-SAME: (ptr [[PTR:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ACCUM_LOAD:%.*]] = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr [[PTR]], i32 4, i1 false, i32 1, i32 1, i32 0)
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi <8 x float> [ [[ACCUM_LOAD]], [[ENTRY:%.*]] ], [ [[MULADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[MULADD]] = call <8 x float> (...) @lgc.cooperative.matrix.muladd__v8f32(<8 x float> [[A]], <8 x float> [[B]], <8 x float> [[ACCUM_PHI]], i1 true, i1 true, i1 false, i1 false, i32 1, i32 1)
; CHECK-NEXT:    [[CC:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[CC]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    call void (...) @lgc.cooperative.matrix.store(ptr [[PTR]], i32 4, i1 true, i32 1, i32 1, i32 0, i32 16, <8 x float> [[MULADD]])
; CHECK-NEXT:    ret void
;
entry:
  %accum.load = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr %ptr, i32 4, i1 false, i32 1, i32 0, i32 0)
  br label %loop

loop:
  %accum.phi = phi <8 x float> [ %accum.load, %entry ], [ %accum.next, %loop ]

  %a = call <8 x float> @getmat1()
  %b = call <8 x float> @getmat1()

  %accum.cvt = call <8 x float> (...) @lgc.cooperative.matrix.convert__v8f32(i32 0, <8 x float> %accum.phi, i32 1, i32 1, i32 0, i32 1)
  %muladd = call <8 x float> (...) @lgc.cooperative.matrix.muladd__v8f32(<8 x float> %a, <8 x float> %b, <8 x float> %accum.cvt, i1 true, i1 true, i1 false, i1 false, i32 1, i32 1)
  %accum.next = call <8 x float> (...) @lgc.cooperative.matrix.convert__v8f32(i32 0, <8 x float> %muladd, i32 1, i32 1, i32 1, i32 0)

  %cc = call i1 @getcc()
  br i1 %cc, label %loop, label %end

end:
  call void (...) @lgc.cooperative.matrix.store(ptr %ptr, i32 4, i1 true, i32 1, i32 0, i32 0, i32 16, <8 x float> %accum.next)
  ret void
}

define void @matmul_f16_initzero(ptr %ptr) {
; CHECK-LABEL: define void @matmul_f16_initzero
; CHECK-SAME: (ptr [[PTR:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi <8 x float> [ zeroinitializer, [[ENTRY:%.*]] ], [ [[MULADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[MULADD]] = call <8 x float> (...) @lgc.cooperative.matrix.muladd__v8f32(<8 x float> [[A]], <8 x float> [[B]], <8 x float> [[ACCUM_PHI]], i1 true, i1 true, i1 false, i1 false, i32 1, i32 1)
; CHECK-NEXT:    [[CC:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[CC]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    call void (...) @lgc.cooperative.matrix.store(ptr [[PTR]], i32 4, i1 true, i32 1, i32 1, i32 0, i32 16, <8 x float> [[MULADD]])
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %accum.phi = phi <8 x float> [ zeroinitializer, %entry ], [ %accum.next, %loop ]

  %a = call <8 x float> @getmat1()
  %b = call <8 x float> @getmat1()

  %accum.cvt = call <8 x float> (...) @lgc.cooperative.matrix.convert__v8f32(i32 0, <8 x float> %accum.phi, i32 1, i32 1, i32 0, i32 1)
  %muladd = call <8 x float> (...) @lgc.cooperative.matrix.muladd__v8f32(<8 x float> %a, <8 x float> %b, <8 x float> %accum.cvt, i1 true, i1 true, i1 false, i1 false, i32 1, i32 1)
  %accum.next = call <8 x float> (...) @lgc.cooperative.matrix.convert__v8f32(i32 0, <8 x float> %muladd, i32 1, i32 1, i32 1, i32 0)

  %cc = call i1 @getcc()
  br i1 %cc, label %loop, label %end

end:
  call void (...) @lgc.cooperative.matrix.store(ptr %ptr, i32 4, i1 true, i32 1, i32 0, i32 0, i32 16, <8 x float> %accum.next)
  ret void
}

declare i1 @getcc()
declare <8 x float> @getmat1()

declare <8 x float> @lgc.cooperative.matrix.load__v8f32(...)
declare <8 x float> @lgc.cooperative.matrix.convert__v8f32(...)
declare void @lgc.cooperative.matrix.store(...)
declare <8 x float> @lgc.cooperative.matrix.muladd__v8f32(...)
