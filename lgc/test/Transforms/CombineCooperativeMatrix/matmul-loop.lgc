; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool lgc
; RUN: lgc -o - -passes=lgc-combine-cooperative-matrix %s | FileCheck --check-prefixes=CHECK %s

define void @matmul_f16(ptr %ptr) {
; CHECK-LABEL: @matmul_f16(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ACCUM_LOAD:%.*]] = call <8 x float> @lgc.cooperative.matrix.load.v8f32.p0.i32.i1.i32.i32.i32(ptr [[PTR:%.*]], i32 4, i1 false, i32 1, i32 1, i32 0)
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi <8 x float> [ [[ACCUM_LOAD]], [[ENTRY:%.*]] ], [ [[MULADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[MULADD]] = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> [[A]], <8 x float> [[B]], <8 x float> [[ACCUM_PHI]], i1 true, i1 true, i32 1, i32 1)
; CHECK-NEXT:    [[CC:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[CC]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    call void @lgc.cooperative.matrix.store.p0.i32.i1.i32.i32.i32.v8f32(ptr [[PTR]], i32 4, i1 true, i32 1, i32 1, i32 0, <8 x float> [[MULADD]])
; CHECK-NEXT:    ret void
;
entry:
  %accum.load = call <8 x float> @lgc.cooperative.matrix.load.v8f32.p0.i32.i1.i32.i32.i32(ptr %ptr, i32 4, i1 false, i32 1, i32 0, i32 0)
  br label %loop

loop:
  %accum.phi = phi <8 x float> [ %accum.load, %entry ], [ %accum.next, %loop ]

  %a = call <8 x float> @getmat1()
  %b = call <8 x float> @getmat1()

  %accum.cvt = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %accum.phi, i32 1, i32 1, i32 0, i32 1)
  %muladd = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> %a, <8 x float> %b, <8 x float> %accum.cvt, i1 true, i1 true, i32 1, i32 1)
  %accum.next = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %muladd, i32 1, i32 1, i32 1, i32 0)

  %cc = call i1 @getcc()
  br i1 %cc, label %loop, label %end

end:
  call void @lgc.cooperative.matrix.store.p0.i32.i1.i32.i32.i32.v8f32(ptr %ptr, i32 4, i1 true, i32 1, i32 0, i32 0, <8 x float> %accum.next)
  ret void
}

define void @matmul_f16_initzero(ptr %ptr) {
; CHECK-LABEL: @matmul_f16_initzero(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[ACCUM_PHI:%.*]] = phi <8 x float> [ zeroinitializer, [[ENTRY:%.*]] ], [ [[MULADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[A:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[B:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[MULADD]] = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> [[A]], <8 x float> [[B]], <8 x float> [[ACCUM_PHI]], i1 true, i1 true, i32 1, i32 1)
; CHECK-NEXT:    [[CC:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[CC]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    call void @lgc.cooperative.matrix.store.p0.i32.i1.i32.i32.i32.v8f32(ptr [[PTR:%.*]], i32 4, i1 true, i32 1, i32 1, i32 0, <8 x float> [[MULADD]])
; CHECK-NEXT:    ret void
;
entry:
  br label %loop

loop:
  %accum.phi = phi <8 x float> [ zeroinitializer, %entry ], [ %accum.next, %loop ]

  %a = call <8 x float> @getmat1()
  %b = call <8 x float> @getmat1()

  %accum.cvt = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %accum.phi, i32 1, i32 1, i32 0, i32 1)
  %muladd = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> %a, <8 x float> %b, <8 x float> %accum.cvt, i1 true, i1 true, i32 1, i32 1)
  %accum.next = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %muladd, i32 1, i32 1, i32 1, i32 0)

  %cc = call i1 @getcc()
  br i1 %cc, label %loop, label %end

end:
  call void @lgc.cooperative.matrix.store.p0.i32.i1.i32.i32.i32.v8f32(ptr %ptr, i32 4, i1 true, i32 1, i32 0, i32 0, <8 x float> %accum.next)
  ret void
}

declare i1 @getcc()
declare <8 x float> @getmat1()

declare <8 x float> @lgc.cooperative.matrix.load.v8f32.p0.i32.i1.i32.i32.i32(ptr, i32, i1, i32, i32, i32)
declare <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32, <8 x float>, i32, i32, i32, i32)
declare void @lgc.cooperative.matrix.store.p0.i32.i1.i32.i32.i32.v8f32(ptr, i32, i1, i32, i32, i32, <8 x float>)
declare <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float>, <8 x float>, <8 x float>, i1, i1, i32, i32)
