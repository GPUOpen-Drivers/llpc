; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool lgc
; RUN: lgc -o - -passes=lgc-combine-cooperative-matrix %s | FileCheck --check-prefixes=CHECK %s

define <8 x float> @insert_transpose(<8 x float> %x) {
; CHECK-LABEL: @insert_transpose(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[GUARD:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[GUARD]], label [[LOOP:%.*]], label [[END:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[V_LOOP:%.*]] = phi <8 x float> [ [[X:%.*]], [[ENTRY:%.*]] ], [ [[MULADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[F:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[MULADD]] = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> [[F]], <8 x float> [[F]], <8 x float> [[V_LOOP]], i1 true, i1 true, i32 1, i32 1)
; CHECK-NEXT:    [[CC:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[CC]], label [[LOOP]], label [[END]]
; CHECK:       end:
; CHECK-NEXT:    [[R:%.*]] = phi <8 x float> [ [[MULADD]], [[LOOP]] ], [ [[X]], [[ENTRY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = call <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float> [[R]], i32 1, i32 0)
; CHECK-NEXT:    ret <8 x float> [[TMP0]]
;
entry:
  %in.t = call <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float> %x, i32 1, i32 0)
  %guard = call i1 @getcc()
  br i1 %guard, label %loop, label %end

loop:
  %v.loop = phi <8 x float> [ %in.t, %entry ], [ %v.next, %loop ]

  %f = call <8 x float> @getmat1()
  %pre.t = call <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float> %v.loop, i32 1, i32 0)
  %muladd = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> %f, <8 x float> %f, <8 x float> %pre.t, i1 true, i1 true, i32 1, i32 1)
  %v.next = call <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float> %muladd, i32 1, i32 0)

  %cc = call i1 @getcc()
  br i1 %cc, label %loop, label %end

end:
  %r = phi <8 x float> [ %v.next, %loop ], [ %in.t, %entry ]
  ret <8 x float> %r
}

define <8 x float> @reuse_transpose(<8 x float> %x) {
; CHECK-LABEL: @reuse_transpose(
; CHECK-NEXT:    [[T1:%.*]] = call <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float> [[X:%.*]], i32 1, i32 0)
; CHECK-NEXT:    [[R:%.*]] = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> [[T1]], <8 x float> [[X]], <8 x float> zeroinitializer, i1 true, i1 true, i32 1, i32 1)
; CHECK-NEXT:    ret <8 x float> [[R]]
;
  %t1 = call <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float> %x, i32 1, i32 0)
  %t2 = call <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float> %t1, i32 1, i32 0)
  %r = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> %t1, <8 x float> %t2, <8 x float> zeroinitializer, i1 true, i1 true, i32 1, i32 1)
  ret <8 x float> %r
}

; NOTE: This test leaves a convert inside the loop. Rely on other passes to sink it out.
define <8 x float> @insert_convert(ptr %ptr) {
; CHECK-LABEL: @insert_convert(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LOAD:%.*]] = call <8 x float> @lgc.cooperative.matrix.load.v8f32.p0.i32.i1.i32.i32.i32(ptr [[PTR:%.*]], i32 4, i1 false, i32 1, i32 1, i32 0)
; CHECK-NEXT:    [[GUARD:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[GUARD]], label [[LOOP:%.*]], label [[END:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[V_LOOP:%.*]] = phi <8 x float> [ [[LOAD]], [[ENTRY:%.*]] ], [ [[MULADD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[F:%.*]] = call <8 x float> @getmat1()
; CHECK-NEXT:    [[MULADD]] = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> [[F]], <8 x float> [[F]], <8 x float> [[V_LOOP]], i1 true, i1 true, i32 1, i32 1)
; CHECK-NEXT:    [[CC:%.*]] = call i1 @getcc()
; CHECK-NEXT:    br i1 [[CC]], label [[LOOP]], label [[END]]
; CHECK:       end:
; CHECK-NEXT:    [[R:%.*]] = phi <8 x float> [ [[MULADD]], [[LOOP]] ], [ [[LOAD]], [[ENTRY]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> [[R]], i32 1, i32 1, i32 1, i32 0)
; CHECK-NEXT:    ret <8 x float> [[TMP0]]
;
entry:
  %load = call <8 x float> @lgc.cooperative.matrix.load.v8f32.p0.i32.i1.i32.i32.i32(ptr %ptr, i32 4, i1 false, i32 1, i32 0, i32 0)
  %guard = call i1 @getcc()
  br i1 %guard, label %loop, label %end

loop:
  %v.loop = phi <8 x float> [ %load, %entry ], [ %v.next, %loop ]

  %f = call <8 x float> @getmat1()
  %pre = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %v.loop, i32 1, i32 1, i32 0, i32 1)
  %muladd = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> %f, <8 x float> %f, <8 x float> %pre, i1 true, i1 true, i32 1, i32 1)
  %v.next = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %muladd, i32 1, i32 1, i32 1, i32 0)

  %cc = call i1 @getcc()
  br i1 %cc, label %loop, label %end

end:
  %r = phi <8 x float> [ %v.next, %loop ], [ %load, %entry ]
  ret <8 x float> %r
}

define <8 x float> @reuse_convert(<8 x float> %x) {
; CHECK-LABEL: @reuse_convert(
; CHECK-NEXT:    [[CVT1:%.*]] = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> [[X:%.*]], i32 1, i32 1, i32 0, i32 1)
; CHECK-NEXT:    [[R:%.*]] = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> [[X]], <8 x float> [[X]], <8 x float> [[CVT1]], i1 true, i1 true, i32 1, i32 1)
; CHECK-NEXT:    ret <8 x float> [[R]]
;
  %cvt1 = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %x, i32 1, i32 1, i32 0, i32 1)
  %cvt2 = call <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32 0, <8 x float> %cvt1, i32 1, i32 1, i32 1, i32 0)
  %r = call <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float> %cvt2, <8 x float> %cvt2, <8 x float> %cvt1, i1 true, i1 true, i32 1, i32 1)
  ret <8 x float> %r
}

declare i1 @getcc()
declare <8 x float> @getmat1()

declare <8 x float> @lgc.cooperative.matrix.load.v8f32.p0.i32.i1.i32.i32.i32(ptr, i32, i1, i32, i32, i32)
declare <8 x float> @lgc.cooperative.matrix.transpose.v8f32.v8f32.i32.i32(<8 x float>, i32, i32)
declare <8 x float> @lgc.cooperative.matrix.convert.v8f32.i32.v8f32.i32.i32.i32.i32(i32, <8 x float>, i32, i32, i32, i32)
declare <8 x float> @lgc.cooperative.matrix.muladd.v8f32.v8f32.v8f32.v8f32.i1.i1.i32.i32(<8 x float>, <8 x float>, <8 x float>, i1, i1, i32, i32)
