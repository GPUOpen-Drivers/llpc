; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool lgc
; RUN: lgc -o - -passes='require<lgc-pipeline-state>,function(lgc-patch-buffer-op)' %s | FileCheck --check-prefixes=CHECK %s

define amdgpu_gfx float @simple(<4 x i32> inreg %desc) !lgc.shaderstage !0 {
; CHECK-LABEL: @simple(
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.raw.buffer.load.i32(<4 x i32> [[DESC:%.*]], i32 0, i32 0, i32 0)
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[TMP1]] to float
; CHECK-NEXT:    ret float [[TMP2]]
;
  %ptr = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc)
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

define amdgpu_gfx float @uniform_select(<4 x i32> inreg %desc0, <4 x i32> inreg %desc1, i1 inreg %sel) !lgc.shaderstage !0 {
; CHECK-LABEL: @uniform_select(
; CHECK-NEXT:    [[PTR_0:%.*]] = select i1 [[SEL:%.*]], <4 x i32> [[DESC0:%.*]], <4 x i32> [[DESC1:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.raw.buffer.load.i32(<4 x i32> [[PTR_0]], i32 0, i32 0, i32 0)
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i32 [[TMP1]] to float
; CHECK-NEXT:    ret float [[TMP2]]
;
  %ptr0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  %ptr1 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc1)
  %ptr = select i1 %sel, ptr addrspace(7) %ptr0, ptr addrspace(7) %ptr1
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

define amdgpu_gfx float @divergent_select(<4 x i32> inreg %desc0, <4 x i32> inreg %desc1, i1 %sel) !lgc.shaderstage !0 {
; CHECK-LABEL: @divergent_select(
; CHECK-NEXT:    [[PTR_0:%.*]] = select i1 [[SEL:%.*]], <4 x i32> [[DESC0:%.*]], <4 x i32> [[DESC1:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[PTR_0]], <4 x i32> undef, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], <i32 -1, i32 65535>
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr addrspace(1)
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i32> [[PTR_0]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 0, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr addrspace(1) [[TMP4]], i32 [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr addrspace(1) [[TMP8]], align 4
; CHECK-NEXT:    ret float [[TMP9]]
;
  %ptr0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  %ptr1 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc1)
  %ptr = select i1 %sel, ptr addrspace(7) %ptr0, ptr addrspace(7) %ptr1
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

define amdgpu_gfx float @divergent_select1(<4 x i32> %desc0, <4 x i32> inreg %desc1, i1 inreg %sel) !lgc.shaderstage !0 {
; CHECK-LABEL: @divergent_select1(
; CHECK-NEXT:    [[PTR_0:%.*]] = select i1 [[SEL:%.*]], <4 x i32> [[DESC0:%.*]], <4 x i32> [[DESC1:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[PTR_0]], <4 x i32> undef, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], <i32 -1, i32 65535>
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr addrspace(1)
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i32> [[PTR_0]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 0, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr addrspace(1) [[TMP4]], i32 [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr addrspace(1) [[TMP8]], align 4
; CHECK-NEXT:    ret float [[TMP9]]
;
  %ptr0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  %ptr1 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc1)
  %ptr = select i1 %sel, ptr addrspace(7) %ptr0, ptr addrspace(7) %ptr1
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

define amdgpu_gfx float @divergent_select2(<4 x i32> inreg %desc0, <4 x i32> %desc1, i1 inreg %sel) !lgc.shaderstage !0 {
; CHECK-LABEL: @divergent_select2(
; CHECK-NEXT:    [[PTR_0:%.*]] = select i1 [[SEL:%.*]], <4 x i32> [[DESC0:%.*]], <4 x i32> [[DESC1:%.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[PTR_0]], <4 x i32> undef, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], <i32 -1, i32 65535>
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr addrspace(1)
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i32> [[PTR_0]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 0, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr addrspace(1) [[TMP4]], i32 [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr addrspace(1) [[TMP8]], align 4
; CHECK-NEXT:    ret float [[TMP9]]
;
  %ptr0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  %ptr1 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc1)
  %ptr = select i1 %sel, ptr addrspace(7) %ptr0, ptr addrspace(7) %ptr1
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

define amdgpu_gfx void @divergent_phi_uniform_desc(<4 x i32> inreg %desc0, i32 %stride) !lgc.shaderstage !0 {
; CHECK-LABEL: @divergent_phi_uniform_desc(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PTR_PHI_1:%.*]] = phi ptr addrspace(6) [ null, [[ENTRY:%.*]] ], [ [[TMP1:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[CTR:%.*]] = phi i32 [ 0, [[ENTRY]] ], [ [[CTR_NEXT:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint ptr addrspace(6) [[PTR_PHI_1]] to i32
; CHECK-NEXT:    call void @llvm.amdgcn.raw.buffer.store.i32(i32 0, <4 x i32> [[DESC0:%.*]], i32 [[TMP0]], i32 0, i32 0)
; CHECK-NEXT:    [[TMP1]] = getelementptr i32, ptr addrspace(6) [[PTR_PHI_1]], i32 [[STRIDE:%.*]]
; CHECK-NEXT:    [[CTR_NEXT]] = add i32 [[CTR]], 1
; CHECK-NEXT:    [[CC:%.*]] = icmp ne i32 [[CTR_NEXT]], 1024
; CHECK-NEXT:    br i1 [[CC]], label [[LOOP]], label [[END:%.*]]
; CHECK:       end:
; CHECK-NEXT:    ret void
;
entry:
  %ptr.0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  br label %loop

loop:
  %ptr.phi = phi ptr addrspace(7) [ %ptr.0, %entry ], [ %ptr.next, %loop ]
  %ctr = phi i32 [ 0, %entry ], [ %ctr.next, %loop ]
  store i32 0, ptr addrspace(7) %ptr.phi
  %ptr.next = getelementptr i32, ptr addrspace(7) %ptr.phi, i32 %stride
  %ctr.next = add i32 %ctr, 1
  %cc = icmp ne i32 %ctr.next, 1024
  br i1 %cc, label %loop, label %end

end:
  ret void
}

define amdgpu_gfx float @divergent_input0_phi(<4 x i32> %desc0, <4 x i32> inreg %desc1, i1 inreg %sel) !lgc.shaderstage !0 {
; CHECK-LABEL: @divergent_input0_phi(
; CHECK-NEXT:    br i1 [[SEL:%.*]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       a:
; CHECK-NEXT:    br label [[TAIL:%.*]]
; CHECK:       b:
; CHECK-NEXT:    br label [[TAIL]]
; CHECK:       tail:
; CHECK-NEXT:    [[PTR_0:%.*]] = phi <4 x i32> [ [[DESC0:%.*]], [[A]] ], [ [[DESC1:%.*]], [[B]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[PTR_0]], <4 x i32> undef, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], <i32 -1, i32 65535>
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr addrspace(1)
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i32> [[PTR_0]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 0, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr addrspace(1) [[TMP4]], i32 [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr addrspace(1) [[TMP8]], align 4
; CHECK-NEXT:    ret float [[TMP9]]
;
  br i1 %sel, label %a, label %b

a:
  %ptr0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  br label %tail

b:
  %ptr1 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc1)
  br label %tail

tail:
  %ptr = phi ptr addrspace(7) [ %ptr0, %a ], [ %ptr1, %b ]
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

define amdgpu_gfx float @divergent_input1_phi(<4 x i32> inreg %desc0, <4 x i32> %desc1, i1 inreg %sel) !lgc.shaderstage !0 {
; CHECK-LABEL: @divergent_input1_phi(
; CHECK-NEXT:    br i1 [[SEL:%.*]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       a:
; CHECK-NEXT:    br label [[TAIL:%.*]]
; CHECK:       b:
; CHECK-NEXT:    br label [[TAIL]]
; CHECK:       tail:
; CHECK-NEXT:    [[PTR_0:%.*]] = phi <4 x i32> [ [[DESC0:%.*]], [[A]] ], [ [[DESC1:%.*]], [[B]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[PTR_0]], <4 x i32> undef, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], <i32 -1, i32 65535>
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr addrspace(1)
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i32> [[PTR_0]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 0, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr addrspace(1) [[TMP4]], i32 [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr addrspace(1) [[TMP8]], align 4
; CHECK-NEXT:    ret float [[TMP9]]
;
  br i1 %sel, label %a, label %b

a:
  %ptr0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  br label %tail

b:
  %ptr1 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc1)
  br label %tail

tail:
  %ptr = phi ptr addrspace(7) [ %ptr0, %a ], [ %ptr1, %b ]
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

define amdgpu_gfx float @divergent_sync_phi(<4 x i32> inreg %desc0, <4 x i32> inreg %desc1, i1 %sel) !lgc.shaderstage !0 {
; CHECK-LABEL: @divergent_sync_phi(
; CHECK-NEXT:    br i1 [[SEL:%.*]], label [[A:%.*]], label [[B:%.*]]
; CHECK:       a:
; CHECK-NEXT:    br label [[TAIL:%.*]]
; CHECK:       b:
; CHECK-NEXT:    br label [[TAIL]]
; CHECK:       tail:
; CHECK-NEXT:    [[PTR_0:%.*]] = phi <4 x i32> [ [[DESC0:%.*]], [[A]] ], [ [[DESC1:%.*]], [[B]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = shufflevector <4 x i32> [[PTR_0]], <4 x i32> undef, <2 x i32> <i32 0, i32 1>
; CHECK-NEXT:    [[TMP2:%.*]] = and <2 x i32> [[TMP1]], <i32 -1, i32 65535>
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
; CHECK-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr addrspace(1)
; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i32> [[PTR_0]], i64 2
; CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 0, [[TMP5]]
; CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr i8, ptr addrspace(1) [[TMP4]], i32 [[TMP7]]
; CHECK-NEXT:    [[TMP9:%.*]] = load float, ptr addrspace(1) [[TMP8]], align 4
; CHECK-NEXT:    ret float [[TMP9]]
;
  br i1 %sel, label %a, label %b

a:
  %ptr0 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc0)
  br label %tail

b:
  %ptr1 = call ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32> %desc1)
  br label %tail

tail:
  %ptr = phi ptr addrspace(7) [ %ptr0, %a ], [ %ptr1, %b ]
  %r = load float, ptr addrspace(7) %ptr
  ret float %r
}

declare ptr addrspace(7) @lgc.buffer.desc.to.ptr(<4 x i32>) nounwind readnone

!0 = !{i32 7}
