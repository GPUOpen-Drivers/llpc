
;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;
 ;  Copyright (c) 2024-2025 Advanced Micro Devices, Inc. All Rights Reserved.
 ;
 ;  Permission is hereby granted, free of charge, to any person obtaining a copy
 ;  of this software and associated documentation files (the "Software"), to
 ;  deal in the Software without restriction, including without limitation the
 ;  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 ;  sell copies of the Software, and to permit persons to whom the Software is
 ;  furnished to do so, subject to the following conditions:
 ;
 ;  The above copyright notice and this permission notice shall be included in all
 ;  copies or substantial portions of the Software.
 ;
 ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 ;  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 ;  IN THE SOFTWARE.
 ;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --tool lgc
; RUN: lgc -o - -passes=lgc-lower-read-first-lane %s | FileCheck --check-prefixes=CHECK %s

define i32 @simple(i32 %x) {
; CHECK-LABEL: @simple(
; CHECK-NEXT:    [[Y:%.*]] = mul i32 [[X:%.*]], 2
; CHECK-NEXT:    [[R:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[Y]])
; CHECK-NEXT:    ret i32 [[R]]
;
  %y = mul i32 %x, 2
  %r = call i32 @llvm.amdgcn.readfirstlane(i32 %y)
  ret i32 %r
}

define i32 @simple2(i32 %x) {
; CHECK-LABEL: @simple2(
; CHECK-NEXT:    [[A:%.*]] = mul i32 [[X:%.*]], 5
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[A]])
; CHECK-NEXT:    [[B:%.*]] = add i32 [[TMP1]], 2
; CHECK-NEXT:    [[R:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[B]])
; CHECK-NEXT:    ret i32 [[R]]
;
  %a = mul i32 %x, 5
  %b = add i32 %a, 2
  %r = call i32 @llvm.amdgcn.readfirstlane(i32 %b)
  ret i32 %r
}

define <2 x i32> @vec2(ptr addrspace(4) %ptr) {
; CHECK-LABEL: @vec2(
; CHECK-NEXT:    [[PTR_OFS:%.*]] = getelementptr <2 x i32>, ptr addrspace(4) [[PTR:%.*]], i32 2
; CHECK-NEXT:    [[DESC:%.*]] = load <2 x i32>, ptr addrspace(4) [[PTR_OFS]], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = call <2 x i32> @llvm.amdgcn.readfirstlane.v2i32(<2 x i32> [[DESC]])
; CHECK-NEXT:    [[DESC_0:%.*]] = extractelement <2 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[DESC_1:%.*]] = extractelement <2 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[RF_0:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[DESC_0]])
; CHECK-NEXT:    [[RF_1:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[DESC_1]])
; CHECK-NEXT:    [[OUT_0:%.*]] = insertelement <2 x i32> poison, i32 [[RF_0]], i32 0
; CHECK-NEXT:    [[OUT_1:%.*]] = insertelement <2 x i32> [[OUT_0]], i32 [[RF_1]], i32 1
; CHECK-NEXT:    ret <2 x i32> [[OUT_1]]
;
  %ptr.ofs = getelementptr <2 x i32>, ptr addrspace(4) %ptr, i32 2
  %desc = load <2 x i32>, ptr addrspace(4) %ptr.ofs, align 16
  %desc.0 = extractelement <2 x i32> %desc, i32 0
  %desc.1 = extractelement <2 x i32> %desc, i32 1
  %rf.0 = call i32 @llvm.amdgcn.readfirstlane(i32 %desc.0)
  %rf.1 = call i32 @llvm.amdgcn.readfirstlane(i32 %desc.1)
  %out.0 = insertelement <2 x i32> poison, i32 %rf.0, i32 0
  %out.1 = insertelement <2 x i32> %out.0, i32 %rf.1, i32 1
  ret <2 x i32> %out.1
}

define i32 @bool(i32 %off) {
; CHECK-LABEL: @bool(
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[OFF:%.*]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = call i1 @llvm.amdgcn.readfirstlane.i1(i1 [[CMP]])
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[TMP1]], i64 32, i64 0
; CHECK-NEXT:    [[PTR_OFS:%.*]] = getelementptr i32, ptr addrspace(4) null, i64 [[SEL]]
; CHECK-NEXT:    [[DESC:%.*]] = load i32, ptr addrspace(4) [[PTR_OFS]], align 16
; CHECK-NEXT:    [[RF:%.*]] = call i32 @llvm.amdgcn.readfirstlane.i32(i32 [[DESC]])
; CHECK-NEXT:    ret i32 [[RF]]
;
  %cmp = icmp ugt i32 %off, 1
  %sel = select i1 %cmp, i64 32, i64 0
  %ptr.ofs = getelementptr i32, ptr addrspace(4) null, i64 %sel
  %desc = load i32, ptr addrspace(4) %ptr.ofs, align 16
  %rf = call i32 @llvm.amdgcn.readfirstlane(i32 %desc)
  ret i32 %rf
}

; Function Attrs: convergent nocallback nofree nounwind willreturn memory(none)
declare i32 @llvm.amdgcn.readfirstlane.i32(i32)

; Function Attrs: convergent nocallback nofree nounwind willreturn memory(none)
declare <2 x i32> @llvm.amdgcn.readfirstlane.v2i32(<2 x i32>)
