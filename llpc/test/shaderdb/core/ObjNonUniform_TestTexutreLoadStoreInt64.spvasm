; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py

; BEGIN_SHADERTEST
; RUN: amdllpc --print-after=llpc-spirv-lower-translator --emit-lgc -o - %s | FileCheck -check-prefixes=SHADERTEST %s
; #version 450
; #extension GL_EXT_nonuniform_qualifier : require
; #extension GL_ARB_gpu_shader_int64 : require
; layout(set = 0, binding = 7) uniform sampler2D _11[];
; layout(location = 0) out vec4 _3;
; layout(location = 1) flat in u64vec2 _4;
; void main()
; {
;     uint64_t _12 = _4.x;
;     sampler2D s = _11[nonuniformEXT(_12)];
;     _3 = texture(s, vec2(0.0, 0.0));
; }

; SPIR-Vrun_update_llpc_test.bat
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 11
; Bound: 34
; Schema: 0
               OpCapability Shader
               OpCapability Int64
               OpCapability ShaderNonUniform
               OpCapability RuntimeDescriptorArray
               OpCapability SampledImageArrayNonUniformIndexing
               OpExtension "SPV_EXT_descriptor_indexing"
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Fragment %main "main" %_4 %_3
               OpExecutionMode %main OriginUpperLeft
               OpSource GLSL 450
               OpSourceExtension "GL_ARB_gpu_shader_int64"
               OpSourceExtension "GL_EXT_nonuniform_qualifier"
               OpName %main "main"
               OpName %_12 "_12"
               OpName %_4 "_4"
               OpName %_3 "_3"
               OpName %_11 "_11"
               OpDecorate %_4 Flat
               OpDecorate %_4 Location 1
               OpDecorate %_3 Location 0
               OpDecorate %_11 DescriptorSet 0
               OpDecorate %_11 Binding 7
               OpDecorate %26 NonUniform
               OpDecorate %28 NonUniform
               OpDecorate %29 NonUniform
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
       %uint = OpTypeInt 64 0
%_ptr_Function_uint = OpTypePointer Function %uint
     %v2uint = OpTypeVector %uint 2
%_ptr_Input_v2uint = OpTypePointer Input %v2uint
         %_4 = OpVariable %_ptr_Input_v2uint Input
     %uint_0 = OpConstant %uint 0
%_ptr_Input_uint = OpTypePointer Input %uint
      %float = OpTypeFloat 32
    %v4float = OpTypeVector %float 4
%_ptr_Output_v4float = OpTypePointer Output %v4float
         %_3 = OpVariable %_ptr_Output_v4float Output
         %20 = OpTypeImage %float 2D 0 0 0 1 Unknown
         %21 = OpTypeSampledImage %20
%_runtimearr_21 = OpTypeRuntimeArray %21
%_ptr_UniformConstant__runtimearr_21 = OpTypePointer UniformConstant %_runtimearr_21
%_ptr_Function_type_2d_image = OpTypePointer Function %21
        %_11 = OpVariable %_ptr_UniformConstant__runtimearr_21 UniformConstant
%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
    %v2float = OpTypeVector %float 2
    %float_0 = OpConstant %float 0
         %32 = OpConstantComposite %v2float %float_0 %float_0
       %main = OpFunction %void None %3
          %5 = OpLabel
        %_12 = OpVariable %_ptr_Function_uint Function
        %texture = OpVariable %_ptr_Function_type_2d_image Function
         %14 = OpAccessChain %_ptr_Input_uint %_4 %uint_0
         %15 = OpLoad %uint %14
               OpStore %_12 %15
         %25 = OpLoad %uint %_12
         %26 = OpCopyObject %uint %25
         %28 = OpAccessChain %_ptr_UniformConstant_21 %_11 %26
         %29 = OpLoad %21 %28
               OpStore %texture %29
  %loadImage = OpLoad %21 %texture
         %33 = OpImageSampleImplicitLod %v4float %loadImage %32
               OpStore %_3 %33
               OpReturn
               OpFunctionEnd
; CHECK-LABEL: @main(
; CHECK-NEXT:  .entry:
; CHECK-NEXT:     [[TMP:%.*]] = alloca { [3 x <8 x i32>], { <4 x i32>, i32 } }, align 32, addrspace(5)
; CHECK-NEXT:     %_12 = alloca i64, align 8, addrspace(5)
; CHECK-NEXT:     [[TMP:%.*]] = load i64, ptr addrspace(64) @_4, align 8
; CHECK-NEXT:     store i64 %1, ptr addrspace(5) %_12, align 8
; CHECK-NEXT:     [[TMP:%.*]] = load i64, ptr addrspace(5) %_12, align 8
; CHECK-NEXT:     call void @spirv.NonUniform.i64(i64 %2)
; CHECK-NEXT:     [[TMP:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 1, i32 1, i64 0, i32 7)
; CHECK-NEXT:     [[TMP:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 1, i32 1, i64 0, i32 7)
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } poison, ptr addrspace(4) %3, 0
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } %5, i32 %4, 1
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } %6, i32 32, 2
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } %7, i32 1, 3
; CHECK-NEXT:     [[TMP:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 2, i32 2, i64 0, i32 7)
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } zeroinitializer, ptr addrspace(4) %9, 0
; CHECK-NEXT:     [[TMP:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 2, i32 2, i64 0, i32 7)
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } %10, i32 %11, 1
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } poison, { ptr addrspace(4), i32, i32, i32 } %8, 0
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } %13, { ptr addrspace(4), i32, i32 } %12, 1
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } %14, 0
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } %14, 1
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { ptr addrspace(4), i32, i32, i32 } %15, 0
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { ptr addrspace(4), i32, i32, i32 } %15, 1
; CHECK-NEXT:     [[TMP:%.*]] = trunc i64 %2 to i32
; CHECK-NEXT:     [[TMP:%.*]] = mul i32 %19, %18
; CHECK-NEXT:     [[TMP:%.*]] = getelementptr i8, ptr addrspace(4) %17, i32 %20
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } %15, ptr addrspace(4) %21, 0
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } %16, 0
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } %16, 1
; CHECK-NEXT:     [[TMP:%.*]] = trunc i64 %2 to i32
; CHECK-NEXT:     [[TMP:%.*]] = mul i32 %25, %24
; CHECK-NEXT:     [[TMP:%.*]] = getelementptr i8, ptr addrspace(4) %23, i32 %26
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } %16, ptr addrspace(4) %27, 0
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } poison, { ptr addrspace(4), i32, i32, i32 } %22, 0
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } %29, { ptr addrspace(4), i32, i32 } %28, 1
; CHECK-NEXT:     call void @"spirv.NonUniform.s[s[p4,i32,i32,i32],s[p4,i32,i32]]"({ { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } %30)
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } %30, 1
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } %31, 2
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } %31, 0
; CHECK-NEXT:     [[TMP:%.*]] = load <4 x i32>, ptr addrspace(4) %33, align 16, !invariant.load !4
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { <4 x i32>, i32 } poison, <4 x i32> %34, 0
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { <4 x i32>, i32 } %35, i32 %32, 1
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } %30, 0
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { ptr addrspace(4), i32, i32, i32 } %37, 0
; CHECK-NEXT:     [[TMP:%.*]] = load <8 x i32>, ptr addrspace(4) %38, align 32, !invariant.load !4
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue [3 x <8 x i32>] poison, <8 x i32> %39, 0
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { [3 x <8 x i32>], { <4 x i32>, i32 } } poison, [3 x <8 x i32>] %40, 0
; CHECK-NEXT:     [[TMP:%.*]] = insertvalue { [3 x <8 x i32>], { <4 x i32>, i32 } } %41, { <4 x i32>, i32 } %36, 1
; CHECK-NEXT:     call void @"spirv.NonUniform.s[a3v8i32,s[v4i32,i32]]"({ [3 x <8 x i32>], { <4 x i32>, i32 } } %42)
; CHECK-NEXT:     store { [3 x <8 x i32>], { <4 x i32>, i32 } } %42, ptr addrspace(5) %0, align 32
; CHECK-NEXT:     [[TMP:%.*]] = load { [3 x <8 x i32>], { <4 x i32>, i32 } }, ptr addrspace(5) %0, align 32
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { [3 x <8 x i32>], { <4 x i32>, i32 } } %43, 1
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { [3 x <8 x i32>], { <4 x i32>, i32 } } %43, 0
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue [3 x <8 x i32>] %45, 0
; CHECK-NEXT:     [[TMP:%.*]] = extractvalue { <4 x i32>, i32 } %44, 0
; CHECK-NEXT:     [[TMP:%.*]] = call reassoc nnan nsz arcp contract afn <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 512, <8 x i32> %46, <4 x i32> %47, i32 1, <2 x float> zeroinitializer)
; CHECK-NEXT:     store <4 x float> %48, ptr addrspace(65) @_3, align 16
; SHADERTEST-LABEL: @lgc.shader.FS.main(
; SHADERTEST-NEXT:  .entry:
; SHADERTEST-NEXT:    [[TMP0:%.*]] = call <2 x i64> (...) @lgc.create.read.generic.input.v2i64(i32 1, i32 0, i32 0, i32 0, i32 17, i32 poison)
; SHADERTEST-NEXT:    [[__LLPC_INPUT_PROXY__4_0_VEC_EXTRACT:%.*]] = extractelement <2 x i64> [[TMP0]], i64 0
; SHADERTEST-NEXT:    [[TMP1:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 1, i32 1, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP2:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 1, i32 1, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP3:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } poison, i32 [[TMP2]], 1
; SHADERTEST-NEXT:    [[TMP4:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } [[TMP3]], i32 32, 2
; SHADERTEST-NEXT:    [[TMP5:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } [[TMP4]], i32 1, 3
; SHADERTEST-NEXT:    [[TMP6:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 2, i32 2, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP7:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 2, i32 2, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP8:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } zeroinitializer, i32 [[TMP7]], 1
; SHADERTEST-NEXT:    [[TMP9:%.*]] = trunc i64 [[__LLPC_INPUT_PROXY__4_0_VEC_EXTRACT]] to i32
; SHADERTEST-NEXT:    [[TMP10:%.*]] = mul i32 [[TMP2]], [[TMP9]]
; SHADERTEST-NEXT:    [[TMP11:%.*]] = sext i32 [[TMP10]] to i64
; SHADERTEST-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr addrspace(4) [[TMP1]], i64 [[TMP11]]
; SHADERTEST-NEXT:    [[TMP13:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } [[TMP5]], ptr addrspace(4) [[TMP12]], 0
; SHADERTEST-NEXT:    [[TMP14:%.*]] = mul i32 [[TMP7]], [[TMP9]]
; SHADERTEST-NEXT:    [[TMP15:%.*]] = sext i32 [[TMP14]] to i64
; SHADERTEST-NEXT:    [[TMP16:%.*]] = getelementptr i8, ptr addrspace(4) [[TMP6]], i64 [[TMP15]]
; SHADERTEST-NEXT:    [[TMP17:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } [[TMP8]], ptr addrspace(4) [[TMP16]], 0
; SHADERTEST-NEXT:    [[TMP18:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } poison, { ptr addrspace(4), i32, i32, i32 } [[TMP13]], 0
; SHADERTEST-NEXT:    [[TMP19:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[TMP18]], { ptr addrspace(4), i32, i32 } [[TMP17]], 1
; SHADERTEST-NEXT:    [[TMP20:%.*]] = load <4 x i32>, ptr addrspace(4) [[TMP16]], align 16, !invariant.load !7
; SHADERTEST-NEXT:    [[TMP21:%.*]] = insertvalue { <4 x i32>, i32 } poison, <4 x i32> [[TMP20]], 0
; SHADERTEST-NEXT:    [[TMP22:%.*]] = insertvalue { <4 x i32>, i32 } [[TMP21]], i32 0, 1
; SHADERTEST-NEXT:    [[TMP23:%.*]] = load <8 x i32>, ptr addrspace(4) [[TMP12]], align 32, !invariant.load !7
; SHADERTEST-NEXT:    [[TMP24:%.*]] = insertvalue [3 x <8 x i32>] poison, <8 x i32> [[TMP23]], 0
; SHADERTEST-NEXT:    [[TMP25:%.*]] = insertvalue { [3 x <8 x i32>], { <4 x i32>, i32 } } poison, [3 x <8 x i32>] [[TMP24]], 0
; SHADERTEST-NEXT:    [[TMP26:%.*]] = insertvalue { [3 x <8 x i32>], { <4 x i32>, i32 } } [[TMP25]], { <4 x i32>, i32 } [[TMP22]], 1
; SHADERTEST-NEXT:    [[TMP27:%.*]] = call reassoc nnan nsz arcp contract afn <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 512, <8 x i32> [[TMP23]], <4 x i32> [[TMP20]], i32 1, <2 x float> zeroinitializer)
; SHADERTEST-NEXT:    call void (...) @lgc.create.write.generic.output(<4 x float> [[TMP27]], i32 0, i32 0, i32 0, i32 0, i32 0, i32 poison)
; SHADERTEST-NEXT:    ret void
;
