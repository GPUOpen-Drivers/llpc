
;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;
 ;  Copyright (c) 2024-2025 Advanced Micro Devices, Inc. All Rights Reserved.
 ;
 ;  Permission is hereby granted, free of charge, to any person obtaining a copy
 ;  of this software and associated documentation files (the "Software"), to
 ;  deal in the Software without restriction, including without limitation the
 ;  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 ;  sell copies of the Software, and to permit persons to whom the Software is
 ;  furnished to do so, subject to the following conditions:
 ;
 ;  The above copyright notice and this permission notice shall be included in all
 ;  copies or substantial portions of the Software.
 ;
 ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 ;  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 ;  IN THE SOFTWARE.
 ;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py

; BEGIN_SHADERTEST
; RUN: amdllpc --print-after=lower-translator -filetype=asm -o - 2>&1 %s | FileCheck -check-prefixes=SHADERTEST %s
; #version 450
; #extension GL_EXT_nonuniform_qualifier : require
; #extension GL_ARB_gpu_shader_int64 : require
; layout(set = 0, binding = 7) uniform sampler2D _11[];
; layout(location = 0) out vec4 _3;
; layout(location = 1) flat in u64vec2 _4;
; void main()
; {
;     uint64_t _12 = _4.x;
;     sampler2D s = _11[nonuniformEXT(_12)];
;     _3 = texture(s, vec2(0.0, 0.0));
; }

; SPIR-Vrun_update_llpc_test.bat
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 11
; Bound: 34
; Schema: 0
               OpCapability Shader
               OpCapability Int64
               OpCapability ShaderNonUniform
               OpCapability RuntimeDescriptorArray
               OpCapability SampledImageArrayNonUniformIndexing
               OpExtension "SPV_EXT_descriptor_indexing"
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Fragment %main "main" %_4 %_3
               OpExecutionMode %main OriginUpperLeft
               OpSource GLSL 450
               OpSourceExtension "GL_ARB_gpu_shader_int64"
               OpSourceExtension "GL_EXT_nonuniform_qualifier"
               OpName %main "main"
               OpName %_12 "_12"
               OpName %_4 "_4"
               OpName %_3 "_3"
               OpName %_11 "_11"
               OpDecorate %_4 Flat
               OpDecorate %_4 Location 1
               OpDecorate %_3 Location 0
               OpDecorate %_11 DescriptorSet 0
               OpDecorate %_11 Binding 7
               OpDecorate %26 NonUniform
               OpDecorate %28 NonUniform
               OpDecorate %29 NonUniform
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
       %uint = OpTypeInt 64 0
%_ptr_Function_uint = OpTypePointer Function %uint
     %v2uint = OpTypeVector %uint 2
%_ptr_Input_v2uint = OpTypePointer Input %v2uint
         %_4 = OpVariable %_ptr_Input_v2uint Input
     %uint_0 = OpConstant %uint 0
%_ptr_Input_uint = OpTypePointer Input %uint
      %float = OpTypeFloat 32
    %v4float = OpTypeVector %float 4
%_ptr_Output_v4float = OpTypePointer Output %v4float
         %_3 = OpVariable %_ptr_Output_v4float Output
         %20 = OpTypeImage %float 2D 0 0 0 1 Unknown
         %21 = OpTypeSampledImage %20
%_runtimearr_21 = OpTypeRuntimeArray %21
%_ptr_UniformConstant__runtimearr_21 = OpTypePointer UniformConstant %_runtimearr_21
%_ptr_Function_type_2d_image = OpTypePointer Function %21
        %_11 = OpVariable %_ptr_UniformConstant__runtimearr_21 UniformConstant
%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
    %v2float = OpTypeVector %float 2
    %float_0 = OpConstant %float 0
         %32 = OpConstantComposite %v2float %float_0 %float_0
       %main = OpFunction %void None %3
          %5 = OpLabel
        %_12 = OpVariable %_ptr_Function_uint Function
        %texture = OpVariable %_ptr_Function_type_2d_image Function
         %14 = OpAccessChain %_ptr_Input_uint %_4 %uint_0
         %15 = OpLoad %uint %14
               OpStore %_12 %15
         %25 = OpLoad %uint %_12
         %26 = OpCopyObject %uint %25
         %28 = OpAccessChain %_ptr_UniformConstant_21 %_11 %26
         %29 = OpLoad %21 %28
               OpStore %texture %29
  %loadImage = OpLoad %21 %texture
         %33 = OpImageSampleImplicitLod %v4float %loadImage %32
               OpStore %_3 %33
               OpReturn
               OpFunctionEnd
; SHADERTEST-LABEL: @main(
; SHADERTEST-NEXT:  .entry:
; SHADERTEST-NEXT:    [[TMP0:%.*]] = alloca { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 }, align 8, addrspace(5)
; SHADERTEST-NEXT:    [[_12:%.*]] = alloca i64, align 8, addrspace(5)
; SHADERTEST-NEXT:    [[TMP1:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 1, i32 1, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP2:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 1, i32 1, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP3:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } poison, ptr addrspace(4) [[TMP1]], 0
; SHADERTEST-NEXT:    [[TMP4:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP3]], i32 [[TMP2]], 1
; SHADERTEST-NEXT:    [[TMP5:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP4]], i32 0, 2
; SHADERTEST-NEXT:    [[TMP6:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 2, i32 2, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP7:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 2, i32 2, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP8:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP5]], ptr addrspace(4) [[TMP6]], 3
; SHADERTEST-NEXT:    [[TMP9:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP8]], i32 [[TMP7]], 4
; SHADERTEST-NEXT:    [[_11:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP9]], i32 0, 5
; SHADERTEST-NEXT:    [[TMP10:%.*]] = call ptr addrspace(64) (...) @llpc.structural.gep__p64(ptr addrspace(64) @_4, <2 x i64> poison, i1 false, i32 0, i32 0)
; SHADERTEST-NEXT:    [[TMP11:%.*]] = load i64, ptr addrspace(64) [[TMP10]], align 8
; SHADERTEST-NEXT:    store i64 [[TMP11]], ptr addrspace(5) [[_12]], align 8
; SHADERTEST-NEXT:    [[TMP12:%.*]] = load i64, ptr addrspace(5) [[_12]], align 8
; SHADERTEST-NEXT:    call void @spirv.NonUniform.i64(i64 [[TMP12]])
; SHADERTEST-NEXT:    [[TMP13:%.*]] = trunc i64 [[TMP12]] to i32
; SHADERTEST-NEXT:    [[TMP14:%.*]] = getelementptr [0 x i8], ptr null, i32 0, i32 [[TMP13]]
; SHADERTEST-NEXT:    [[TMP15:%.*]] = ptrtoint ptr [[TMP14]] to i32
; SHADERTEST-NEXT:    [[TMP16:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[_11]], 0
; SHADERTEST-NEXT:    [[TMP17:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[_11]], 1
; SHADERTEST-NEXT:    [[TMP18:%.*]] = mul i32 [[TMP15]], [[TMP17]]
; SHADERTEST-NEXT:    [[TMP19:%.*]] = getelementptr i8, ptr addrspace(4) [[TMP16]], i32 [[TMP18]]
; SHADERTEST-NEXT:    [[TMP20:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[_11]], ptr addrspace(4) [[TMP19]], 0
; SHADERTEST-NEXT:    [[TMP21:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP20]], 3
; SHADERTEST-NEXT:    [[TMP22:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP20]], 4
; SHADERTEST-NEXT:    [[TMP23:%.*]] = mul i32 [[TMP15]], [[TMP22]]
; SHADERTEST-NEXT:    [[TMP24:%.*]] = getelementptr i8, ptr addrspace(4) [[TMP21]], i32 [[TMP23]]
; SHADERTEST-NEXT:    [[TMP25:%.*]] = insertvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP20]], ptr addrspace(4) [[TMP24]], 3
; SHADERTEST-NEXT:    call void @"spirv.NonUniform.s[p4,i32,i32,p4,i32,i32]"({ ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP25]])
; SHADERTEST-NEXT:    call void @"spirv.NonUniform.s[p4,i32,i32,p4,i32,i32]"({ ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP25]])
; SHADERTEST-NEXT:    store { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP25]], ptr addrspace(5) [[TMP0]], align 8
; SHADERTEST-NEXT:    [[TMP26:%.*]] = load { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 }, ptr addrspace(5) [[TMP0]], align 8
; SHADERTEST-NEXT:    [[TMP27:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP26]], 0
; SHADERTEST-NEXT:    [[TMP28:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP26]], 2
; SHADERTEST-NEXT:    [[TMP29:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP26]], 3
; SHADERTEST-NEXT:    [[TMP30:%.*]] = extractvalue { ptr addrspace(4), i32, i32, ptr addrspace(4), i32, i32 } [[TMP26]], 5
; SHADERTEST-NEXT:    [[TMP31:%.*]] = call reassoc nnan nsz arcp contract afn <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 512, ptr addrspace(4) [[TMP27]], ptr addrspace(4) [[TMP29]], i32 1, <2 x float> zeroinitializer)
; SHADERTEST-NEXT:    store <4 x float> [[TMP31]], ptr addrspace(65) @_3, align 16
; SHADERTEST-NEXT:    ret void
;
