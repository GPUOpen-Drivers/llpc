; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py

; BEGIN_SHADERTEST
; RUN: amdllpc --print-after=llpc-spirv-lower-translator -filetype=asm -o - 2>&1 %s | FileCheck -check-prefixes=SHADERTEST %s
; #version 450
; #extension GL_EXT_nonuniform_qualifier : require
; #extension GL_ARB_gpu_shader_int64 : require
; layout(set = 0, binding = 7) uniform sampler2D _11[];
; layout(location = 0) out vec4 _3;
; layout(location = 1) flat in u64vec2 _4;
; void main()
; {
;     uint64_t _12 = _4.x;
;     sampler2D s = _11[nonuniformEXT(_12)];
;     _3 = texture(s, vec2(0.0, 0.0));
; }

; SPIR-Vrun_update_llpc_test.bat
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 11
; Bound: 34
; Schema: 0
               OpCapability Shader
               OpCapability Int64
               OpCapability ShaderNonUniform
               OpCapability RuntimeDescriptorArray
               OpCapability SampledImageArrayNonUniformIndexing
               OpExtension "SPV_EXT_descriptor_indexing"
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Fragment %main "main" %_4 %_3
               OpExecutionMode %main OriginUpperLeft
               OpSource GLSL 450
               OpSourceExtension "GL_ARB_gpu_shader_int64"
               OpSourceExtension "GL_EXT_nonuniform_qualifier"
               OpName %main "main"
               OpName %_12 "_12"
               OpName %_4 "_4"
               OpName %_3 "_3"
               OpName %_11 "_11"
               OpDecorate %_4 Flat
               OpDecorate %_4 Location 1
               OpDecorate %_3 Location 0
               OpDecorate %_11 DescriptorSet 0
               OpDecorate %_11 Binding 7
               OpDecorate %26 NonUniform
               OpDecorate %28 NonUniform
               OpDecorate %29 NonUniform
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
       %uint = OpTypeInt 64 0
%_ptr_Function_uint = OpTypePointer Function %uint
     %v2uint = OpTypeVector %uint 2
%_ptr_Input_v2uint = OpTypePointer Input %v2uint
         %_4 = OpVariable %_ptr_Input_v2uint Input
     %uint_0 = OpConstant %uint 0
%_ptr_Input_uint = OpTypePointer Input %uint
      %float = OpTypeFloat 32
    %v4float = OpTypeVector %float 4
%_ptr_Output_v4float = OpTypePointer Output %v4float
         %_3 = OpVariable %_ptr_Output_v4float Output
         %20 = OpTypeImage %float 2D 0 0 0 1 Unknown
         %21 = OpTypeSampledImage %20
%_runtimearr_21 = OpTypeRuntimeArray %21
%_ptr_UniformConstant__runtimearr_21 = OpTypePointer UniformConstant %_runtimearr_21
%_ptr_Function_type_2d_image = OpTypePointer Function %21
        %_11 = OpVariable %_ptr_UniformConstant__runtimearr_21 UniformConstant
%_ptr_UniformConstant_21 = OpTypePointer UniformConstant %21
    %v2float = OpTypeVector %float 2
    %float_0 = OpConstant %float 0
         %32 = OpConstantComposite %v2float %float_0 %float_0
       %main = OpFunction %void None %3
          %5 = OpLabel
        %_12 = OpVariable %_ptr_Function_uint Function
        %texture = OpVariable %_ptr_Function_type_2d_image Function
         %14 = OpAccessChain %_ptr_Input_uint %_4 %uint_0
         %15 = OpLoad %uint %14
               OpStore %_12 %15
         %25 = OpLoad %uint %_12
         %26 = OpCopyObject %uint %25
         %28 = OpAccessChain %_ptr_UniformConstant_21 %_11 %26
         %29 = OpLoad %21 %28
               OpStore %texture %29
  %loadImage = OpLoad %21 %texture
         %33 = OpImageSampleImplicitLod %v4float %loadImage %32
               OpStore %_3 %33
               OpReturn
               OpFunctionEnd
; SHADERTEST-LABEL: @main(
; SHADERTEST-NEXT:  .entry:
; SHADERTEST-NEXT:    [[TMP0:%.*]] = alloca { [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } }, align 8, addrspace(5)
; SHADERTEST-NEXT:    [[_12:%.*]] = alloca i64, align 8, addrspace(5)
; SHADERTEST-NEXT:    [[TMP1:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 1, i32 1, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP2:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 1, i32 1, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP3:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } poison, ptr addrspace(4) [[TMP1]], 0
; SHADERTEST-NEXT:    [[TMP4:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } [[TMP3]], i32 [[TMP2]], 1
; SHADERTEST-NEXT:    [[TMP5:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } [[TMP4]], i32 32, 2
; SHADERTEST-NEXT:    [[TMP6:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } [[TMP5]], i32 1, 3
; SHADERTEST-NEXT:    [[TMP7:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4(i32 2, i32 2, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP8:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } zeroinitializer, ptr addrspace(4) [[TMP7]], 0
; SHADERTEST-NEXT:    [[TMP9:%.*]] = call i32 (...) @lgc.create.get.desc.stride.i32(i32 2, i32 2, i64 0, i32 7)
; SHADERTEST-NEXT:    [[TMP10:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } [[TMP8]], i32 [[TMP9]], 1
; SHADERTEST-NEXT:    [[TMP11:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } poison, { ptr addrspace(4), i32, i32, i32 } [[TMP6]], 0
; SHADERTEST-NEXT:    [[_11:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[TMP11]], { ptr addrspace(4), i32, i32 } [[TMP10]], 1
; SHADERTEST-NEXT:    [[TMP12:%.*]] = load i64, ptr addrspace(64) @_4, align 8
; SHADERTEST-NEXT:    store i64 [[TMP12]], ptr addrspace(5) [[_12]], align 8
; SHADERTEST-NEXT:    [[TMP13:%.*]] = load i64, ptr addrspace(5) [[_12]], align 8
; SHADERTEST-NEXT:    call void @spirv.NonUniform.i64(i64 [[TMP13]])
; SHADERTEST-NEXT:    [[TMP14:%.*]] = trunc i64 [[TMP13]] to i32
; SHADERTEST-NEXT:    [[TMP15:%.*]] = getelementptr [4294967295 x i8], ptr null, i32 0, i32 [[TMP14]]
; SHADERTEST-NEXT:    [[TMP16:%.*]] = ptrtoint ptr [[TMP15]] to i32
; SHADERTEST-NEXT:    [[TMP17:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[_11]], 0
; SHADERTEST-NEXT:    [[TMP18:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[_11]], 1
; SHADERTEST-NEXT:    [[TMP19:%.*]] = extractvalue { ptr addrspace(4), i32, i32, i32 } [[TMP17]], 0
; SHADERTEST-NEXT:    [[TMP20:%.*]] = extractvalue { ptr addrspace(4), i32, i32, i32 } [[TMP17]], 1
; SHADERTEST-NEXT:    [[TMP21:%.*]] = mul i32 [[TMP16]], [[TMP20]]
; SHADERTEST-NEXT:    [[TMP22:%.*]] = getelementptr i8, ptr addrspace(4) [[TMP19]], i32 [[TMP21]]
; SHADERTEST-NEXT:    [[TMP23:%.*]] = insertvalue { ptr addrspace(4), i32, i32, i32 } [[TMP17]], ptr addrspace(4) [[TMP22]], 0
; SHADERTEST-NEXT:    [[TMP24:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } [[TMP18]], 0
; SHADERTEST-NEXT:    [[TMP25:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } [[TMP18]], 1
; SHADERTEST-NEXT:    [[TMP26:%.*]] = mul i32 [[TMP16]], [[TMP25]]
; SHADERTEST-NEXT:    [[TMP27:%.*]] = getelementptr i8, ptr addrspace(4) [[TMP24]], i32 [[TMP26]]
; SHADERTEST-NEXT:    [[TMP28:%.*]] = insertvalue { ptr addrspace(4), i32, i32 } [[TMP18]], ptr addrspace(4) [[TMP27]], 0
; SHADERTEST-NEXT:    [[TMP29:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } poison, { ptr addrspace(4), i32, i32, i32 } [[TMP23]], 0
; SHADERTEST-NEXT:    [[TMP30:%.*]] = insertvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[TMP29]], { ptr addrspace(4), i32, i32 } [[TMP28]], 1
; SHADERTEST-NEXT:    call void @"spirv.NonUniform.s[s[p4,i32,i32,i32],s[p4,i32,i32]]"({ { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[TMP30]])
; SHADERTEST-NEXT:    [[TMP31:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[TMP30]], 1
; SHADERTEST-NEXT:    [[TMP32:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } [[TMP31]], 2
; SHADERTEST-NEXT:    [[TMP33:%.*]] = extractvalue { ptr addrspace(4), i32, i32 } [[TMP31]], 0
; SHADERTEST-NEXT:    [[TMP34:%.*]] = insertvalue { ptr addrspace(4), i32 } poison, ptr addrspace(4) [[TMP33]], 0
; SHADERTEST-NEXT:    [[TMP35:%.*]] = insertvalue { ptr addrspace(4), i32 } [[TMP34]], i32 [[TMP32]], 1
; SHADERTEST-NEXT:    [[TMP36:%.*]] = extractvalue { { ptr addrspace(4), i32, i32, i32 }, { ptr addrspace(4), i32, i32 } } [[TMP30]], 0
; SHADERTEST-NEXT:    [[TMP37:%.*]] = extractvalue { ptr addrspace(4), i32, i32, i32 } [[TMP36]], 0
; SHADERTEST-NEXT:    [[TMP38:%.*]] = insertvalue [3 x ptr addrspace(4)] poison, ptr addrspace(4) [[TMP37]], 0
; SHADERTEST-NEXT:    [[TMP39:%.*]] = insertvalue { [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } } poison, [3 x ptr addrspace(4)] [[TMP38]], 0
; SHADERTEST-NEXT:    [[TMP40:%.*]] = insertvalue { [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } } [[TMP39]], { ptr addrspace(4), i32 } [[TMP35]], 1
; SHADERTEST-NEXT:    call void @"spirv.NonUniform.s[a3p4,s[p4,i32]]"({ [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } } [[TMP40]])
; SHADERTEST-NEXT:    store { [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } } [[TMP40]], ptr addrspace(5) [[TMP0]], align 8
; SHADERTEST-NEXT:    [[TMP41:%.*]] = load { [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } }, ptr addrspace(5) [[TMP0]], align 8
; SHADERTEST-NEXT:    [[TMP42:%.*]] = extractvalue { [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } } [[TMP41]], 1
; SHADERTEST-NEXT:    [[TMP43:%.*]] = extractvalue { [3 x ptr addrspace(4)], { ptr addrspace(4), i32 } } [[TMP41]], 0
; SHADERTEST-NEXT:    [[TMP44:%.*]] = extractvalue [3 x ptr addrspace(4)] [[TMP43]], 0
; SHADERTEST-NEXT:    [[TMP45:%.*]] = extractvalue { ptr addrspace(4), i32 } [[TMP42]], 0
; SHADERTEST-NEXT:    [[TMP46:%.*]] = call reassoc nnan nsz arcp contract afn <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 512, ptr addrspace(4) [[TMP44]], ptr addrspace(4) [[TMP45]], i32 1, <2 x float> zeroinitializer)
; SHADERTEST-NEXT:    store <4 x float> [[TMP46]], ptr addrspace(65) @_3, align 16
; SHADERTEST-NEXT:    ret void
;
