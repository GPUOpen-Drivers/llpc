/*
 ***********************************************************************************************************************
 *
 *  Copyright (c) 2024-2025 Advanced Micro Devices, Inc. All Rights Reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 *
 **********************************************************************************************************************/

// NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
// RUN: amdllpc -o - -filetype=asm %s | FileCheck -check-prefixes=CHECK %s
// REQUIRES: do-not-run-me

#version 450
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_clustered : require

layout(set=0, binding=0) buffer Buf {
  float h[32];
} data;

void main() {
  float val = data.h[gl_SubgroupInvocationID];
  val = subgroupMax(val);
  val = subgroupInclusiveMax(val);
  val = subgroupExclusiveMax(val);
  val = subgroupClusteredMax(val, 32);
  data.h[gl_SubgroupInvocationID] = val;
}
// CHECK-LABEL: amdgpu_cs_main:
// CHECK:         s_getpc_b64 s[2:3]
// CHECK-NEXT:    s_mov_b32 s0, s1
// CHECK-NEXT:    s_mov_b32 s1, s3
// CHECK-NEXT:    v_mbcnt_lo_u32_b32 v4, -1, 0
// CHECK-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x0
// CHECK-NEXT:    v_mbcnt_hi_u32_b32 v4, -1, v4
// CHECK-NEXT:    v_lshlrev_b32_e32 v4, 2, v4
// CHECK-NEXT:    s_waitcnt lgkmcnt(0)
// CHECK-NEXT:    buffer_load_dword v5, v4, s[4:7], 0 offen
// CHECK-NEXT:    s_or_saveexec_b64 s[0:1], -1
// CHECK-NEXT:    s_waitcnt vmcnt(0)
// CHECK-NEXT:    v_cndmask_b32_e64 v0, 0xff800000, v5, s[0:1]
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 quad_perm:[1,0,3,2] row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 quad_perm:[2,3,0,1] row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 row_half_mirror row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 row_mirror row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_permlanex16_b32 v1, v0, -1, -1 op_sel:[1,0]
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    v_readlane_b32 s2, v0, 31
// CHECK-NEXT:    v_readlane_b32 s3, v0, 63
// CHECK-NEXT:    v_max_f32_e64 v0, s2, s3
// CHECK-NEXT:    s_mov_b64 exec, s[0:1]
// CHECK-NEXT:    v_mov_b32_e32 v5, v0
// CHECK-NEXT:    s_or_saveexec_b64 s[2:3], -1
// CHECK-NEXT:    v_mov_b32_e32 v0, 0xff800000
// CHECK-NEXT:    v_cndmask_b32_e64 v1, 0xff800000, v5, s[2:3]
// CHECK-NEXT:    v_mov_b32_e32 v2, 0xff800000
// CHECK-NEXT:    s_mov_b32 vcc_lo, 0xffff0000
// CHECK-NEXT:    s_mov_b32 vcc_hi, vcc_lo
// CHECK-NEXT:    v_mov_b32_dpp v0, v1 row_shr:1 row_mask:0xf bank_mask:0xf
// CHECK-NEXT:    v_max_f32_e32 v0, v1, v0
// CHECK-NEXT:    v_mov_b32_e32 v1, 0xff800000
// CHECK-NEXT:    v_mov_b32_dpp v2, v0 row_shr:2 row_mask:0xf bank_mask:0xf
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v2
// CHECK-NEXT:    v_mov_b32_e32 v2, 0xff800000
// CHECK-NEXT:    v_mov_b32_dpp v1, v0 row_shr:4 row_mask:0xf bank_mask:0xe
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    v_mov_b32_dpp v2, v0 row_shr:8 row_mask:0xf bank_mask:0xc
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v2
// CHECK-NEXT:    v_permlanex16_b32 v1, v0, -1, -1 op_sel:[1,0]
// CHECK-NEXT:    v_cndmask_b32_e32 v1, 0xff800000, v1, vcc
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    v_readlane_b32 s0, v0, 31
// CHECK-NEXT:    v_mov_b32_e32 v1, s0
// CHECK-NEXT:    s_mov_b32 s0, 0
// CHECK-NEXT:    s_mov_b32 s1, -1
// CHECK-NEXT:    v_cndmask_b32_e64 v1, 0xff800000, v1, s[0:1]
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    s_mov_b64 exec, s[2:3]
// CHECK-NEXT:    v_mov_b32_e32 v5, v0
// CHECK-NEXT:    s_or_saveexec_b64 s[8:9], -1
// CHECK-NEXT:    v_cndmask_b32_e64 v0, 0xff800000, v5, s[8:9]
// CHECK-NEXT:    s_mov_b32 s2, 0x6543210f
// CHECK-NEXT:    v_mov_b32_e32 v2, 0xff800000
// CHECK-NEXT:    v_mov_b32_e32 v3, 0xff800000
// CHECK-NEXT:    v_permlane16_b32 v0, v0, s2, 0xedcba987 op_sel:[1,0]
// CHECK-NEXT:    v_readlane_b32 s2, v0, 16
// CHECK-NEXT:    v_writelane_b32 v0, s2, 48
// CHECK-NEXT:    s_mov_b32 s2, 0xff800000
// CHECK-NEXT:    v_writelane_b32 v0, s2, 16
// CHECK-NEXT:    s_mov_b32 s2, 0x10001
// CHECK-NEXT:    s_mov_b32 s3, s2
// CHECK-NEXT:    v_permlanex16_b32 v1, v0, 0, -1 op_sel:[1,0]
// CHECK-NEXT:    v_cndmask_b32_e64 v0, v0, v1, s[2:3]
// CHECK-NEXT:    v_mov_b32_e32 v1, 0xff800000
// CHECK-NEXT:    v_mov_b32_dpp v2, v0 row_shr:1 row_mask:0xf bank_mask:0xf
// CHECK-NEXT:    v_mov_b32_dpp v1, v0 row_shr:2 row_mask:0xf bank_mask:0xf
// CHECK-NEXT:    v_mov_b32_dpp v3, v0 row_shr:3 row_mask:0xf bank_mask:0xf
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v2
// CHECK-NEXT:    v_mov_b32_e32 v2, 0xff800000
// CHECK-NEXT:    v_max3_f32 v0, v0, v1, v3
// CHECK-NEXT:    v_mov_b32_e32 v1, 0xff800000
// CHECK-NEXT:    v_mov_b32_dpp v1, v0 row_shr:4 row_mask:0xf bank_mask:0xe
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    v_mov_b32_dpp v2, v0 row_shr:8 row_mask:0xf bank_mask:0xc
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v2
// CHECK-NEXT:    v_permlanex16_b32 v1, v0, -1, -1 op_sel:[1,0]
// CHECK-NEXT:    v_cndmask_b32_e32 v1, 0xff800000, v1, vcc
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    v_readlane_b32 s2, v0, 31
// CHECK-NEXT:    v_mov_b32_e32 v1, s2
// CHECK-NEXT:    v_cndmask_b32_e64 v1, 0xff800000, v1, s[0:1]
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    s_mov_b64 exec, s[8:9]
// CHECK-NEXT:    v_mov_b32_e32 v5, v0
// CHECK-NEXT:    s_or_saveexec_b64 s[0:1], -1
// CHECK-NEXT:    v_cndmask_b32_e64 v0, 0xff800000, v5, s[0:1]
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 quad_perm:[1,0,3,2] row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 quad_perm:[2,3,0,1] row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 row_half_mirror row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_max_f32_dpp v0, v0, v0 row_mirror row_mask:0xf bank_mask:0xf bound_ctrl:1
// CHECK-NEXT:    v_permlanex16_b32 v1, v0, -1, -1 op_sel:[1,0]
// CHECK-NEXT:    v_max_f32_e32 v0, v0, v1
// CHECK-NEXT:    s_mov_b64 exec, s[0:1]
// CHECK-NEXT:    v_mov_b32_e32 v5, v0
// CHECK-NEXT:    buffer_store_dword v5, v4, s[4:7], 0 offen
// CHECK-NEXT:    s_endpgm
