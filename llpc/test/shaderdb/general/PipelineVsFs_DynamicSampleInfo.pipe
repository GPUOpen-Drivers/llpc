
;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;
 ;  Copyright (c) 2024-2025 Advanced Micro Devices, Inc. All Rights Reserved.
 ;
 ;  Permission is hereby granted, free of charge, to any person obtaining a copy
 ;  of this software and associated documentation files (the "Software"), to
 ;  deal in the Software without restriction, including without limitation the
 ;  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 ;  sell copies of the Software, and to permit persons to whom the Software is
 ;  furnished to do so, subject to the following conditions:
 ;
 ;  The above copyright notice and this permission notice shall be included in all
 ;  copies or substantial portions of the Software.
 ;
 ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 ;  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 ;  IN THE SOFTWARE.
 ;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py UTC_ARGS: --function-signature
; RUN: amdllpc -stop-after=lgc-mutate-entry-point -o - %s | FileCheck -check-prefixes=SHADERTEST %s
[Version]
version = 64

[VsGlsl]
#version 440
layout(location = 0) in vec4 vs_in_position_ndc;
layout(location = 1) in vec2 vs_in_position_screen;

layout(location = 0) out vec2 vs_out_pos_screen_fragment;
layout(location = 1) out vec2 vs_out_pos_screen_sample;

out gl_PerVertex {
  vec4  gl_Position;
};
void main (void)
{
  gl_Position					= vs_in_position_ndc;
  vs_out_pos_screen_fragment	= vs_in_position_screen;
  vs_out_pos_screen_sample	= vs_in_position_screen;
}

[VsInfo]
entryPoint = main

[FsGlsl]
#version 440
layout(location = 0) in vec2 fs_in_pos_screen_fragment;
layout(location = 1) sample in vec2 fs_in_pos_screen_sample;

layout(location = 0) out vec4 fs_out_color;

void main (void)
{
   const float threshold = 0.15625;
   const vec2 offset                     = gl_SamplePosition - vec2(0.5, 0.5);
   const vec2 pos_interpolated_at_offset = interpolateAtOffset(fs_in_pos_screen_fragment, offset);
   const bool valuesEqual                = all(lessThan(abs(pos_interpolated_at_offset - fs_in_pos_screen_sample), vec2(threshold)));
   if (valuesEqual)
     fs_out_color = vec4(0.0, 1.0, 0.0, 1.0);
   else
     fs_out_color = vec4(1.0, 0.0, 0.0, 1.0);
}

[FsInfo]
entryPoint = main

[ResourceMapping]
userDataNode[0].visibility = 4
userDataNode[0].type = StreamOutTableVaPtr
userDataNode[0].offsetInDwords = 0
userDataNode[0].sizeInDwords = 1
userDataNode[1].visibility = 2
userDataNode[1].type = IndirectUserDataVaPtr
userDataNode[1].offsetInDwords = 1
userDataNode[1].sizeInDwords = 1
userDataNode[1].indirectUserDataCount = 4

[GraphicsPipelineState]
dynamicSampleInfo=1
colorBuffer[0].format = VK_FORMAT_R8G8B8A8_UNORM
colorBuffer[0].channelWriteMask = 15
colorBuffer[0].blendEnable = 0
colorBuffer[0].blendSrcAlphaToColor = 0

[VertexInputState]
binding[0].binding = 0
binding[0].stride = 24
binding[0].inputRate = VK_VERTEX_INPUT_RATE_VERTEX
attribute[0].location = 0
attribute[0].binding = 0
attribute[0].format = VK_FORMAT_R32G32B32A32_SFLOAT
attribute[0].offset = 0
attribute[1].location = 1
attribute[1].binding = 0
attribute[1].format = VK_FORMAT_R32G32_SFLOAT
attribute[1].offset = 16
; SHADERTEST-LABEL: define {{[^@]+}}@lgc.shader.VS.main
; SHADERTEST-SAME: (i32 inreg noundef [[GLOBALTABLE:%.*]], i32 inreg noundef [[VERTEXBUFFERTABLE:%.*]], i32 inreg noundef [[BASEVERTEX:%.*]], i32 inreg noundef [[BASEINSTANCE:%.*]], i32 noundef [[VERTEXID:%.*]], i32 noundef [[RELVERTEXID:%.*]], i32 noundef [[PRIMITIVEID:%.*]], i32 noundef [[INSTANCEID:%.*]]) #[[ATTR0:[0-9]+]] !spirv.ExecutionModel !13 !lgc.shaderstage !14 {
; SHADERTEST-NEXT:  .entry:
; SHADERTEST-NEXT:    [[TMP0:%.*]] = call i64 @llvm.amdgcn.s.getpc()
; SHADERTEST-NEXT:    [[TMP1:%.*]] = bitcast i64 [[TMP0]] to <2 x i32>
; SHADERTEST-NEXT:    [[VERTEXINDEX:%.*]] = add i32 [[BASEVERTEX]], [[VERTEXID]]
; SHADERTEST-NEXT:    [[TMP2:%.*]] = insertelement <2 x i32> [[TMP1]], i32 [[VERTEXBUFFERTABLE]], i64 0
; SHADERTEST-NEXT:    [[TMP3:%.*]] = bitcast <2 x i32> [[TMP2]] to i64
; SHADERTEST-NEXT:    [[TMP4:%.*]] = inttoptr i64 [[TMP3]] to ptr addrspace(4)
; SHADERTEST-NEXT:    [[TMP5:%.*]] = getelementptr <4 x i32>, ptr addrspace(4) [[TMP4]], i64 0
; SHADERTEST-NEXT:    [[TMP6:%.*]] = load <4 x i32>, ptr addrspace(4) [[TMP5]], align 16, !invariant.load !15
; SHADERTEST-NEXT:    [[TMP7:%.*]] = call i32 @llvm.amdgcn.struct.tbuffer.load.i32{{(\.v4i32)?}}(<4 x i32> [[TMP6]], i32 [[VERTEXINDEX]], i32 16, i32 0, i32 22, i32 0)
; SHADERTEST-NEXT:    [[TMP8:%.*]] = insertelement <2 x i32> poison, i32 [[TMP7]], i64 0
; SHADERTEST-NEXT:    [[TMP9:%.*]] = call i32 @llvm.amdgcn.struct.tbuffer.load.i32{{(\.v4i32)?}}(<4 x i32> [[TMP6]], i32 [[VERTEXINDEX]], i32 20, i32 0, i32 22, i32 0)
; SHADERTEST-NEXT:    [[TMP10:%.*]] = insertelement <2 x i32> [[TMP8]], i32 [[TMP9]], i64 1
; SHADERTEST-NEXT:    [[TMP11:%.*]] = extractelement <2 x i32> [[TMP10]], i32 0
; SHADERTEST-NEXT:    [[TMP12:%.*]] = insertelement <2 x i32> poison, i32 [[TMP11]], i32 0
; SHADERTEST-NEXT:    [[TMP13:%.*]] = extractelement <2 x i32> [[TMP10]], i32 1
; SHADERTEST-NEXT:    [[TMP14:%.*]] = insertelement <2 x i32> [[TMP12]], i32 [[TMP13]], i32 1
; SHADERTEST-NEXT:    [[VERTEX1_0:%.*]] = bitcast <2 x i32> [[TMP14]] to <2 x float>
; SHADERTEST-NEXT:    [[TMP15:%.*]] = getelementptr <4 x i32>, ptr addrspace(4) [[TMP4]], i64 0
; SHADERTEST-NEXT:    [[TMP16:%.*]] = load <4 x i32>, ptr addrspace(4) [[TMP15]], align 16, !invariant.load !15
; SHADERTEST-NEXT:    [[TMP17:%.*]] = call i32 @llvm.amdgcn.struct.tbuffer.load.i32{{(\.v4i32)?}}(<4 x i32> [[TMP16]], i32 [[VERTEXINDEX]], i32 0, i32 0, i32 22, i32 0)
; SHADERTEST-NEXT:    [[TMP18:%.*]] = insertelement <4 x i32> poison, i32 [[TMP17]], i64 0
; SHADERTEST-NEXT:    [[TMP19:%.*]] = call i32 @llvm.amdgcn.struct.tbuffer.load.i32{{(\.v4i32)?}}(<4 x i32> [[TMP16]], i32 [[VERTEXINDEX]], i32 4, i32 0, i32 22, i32 0)
; SHADERTEST-NEXT:    [[TMP20:%.*]] = insertelement <4 x i32> [[TMP18]], i32 [[TMP19]], i64 1
; SHADERTEST-NEXT:    [[TMP21:%.*]] = call i32 @llvm.amdgcn.struct.tbuffer.load.i32{{(\.v4i32)?}}(<4 x i32> [[TMP16]], i32 [[VERTEXINDEX]], i32 8, i32 0, i32 22, i32 0)
; SHADERTEST-NEXT:    [[TMP22:%.*]] = insertelement <4 x i32> [[TMP20]], i32 [[TMP21]], i64 2
; SHADERTEST-NEXT:    [[TMP23:%.*]] = call i32 @llvm.amdgcn.struct.tbuffer.load.i32{{(\.v4i32)?}}(<4 x i32> [[TMP16]], i32 [[VERTEXINDEX]], i32 12, i32 0, i32 22, i32 0)
; SHADERTEST-NEXT:    [[TMP24:%.*]] = insertelement <4 x i32> [[TMP22]], i32 [[TMP23]], i64 3
; SHADERTEST-NEXT:    [[TMP25:%.*]] = extractelement <4 x i32> [[TMP24]], i32 0
; SHADERTEST-NEXT:    [[TMP26:%.*]] = insertelement <4 x i32> poison, i32 [[TMP25]], i32 0
; SHADERTEST-NEXT:    [[TMP27:%.*]] = extractelement <4 x i32> [[TMP24]], i32 1
; SHADERTEST-NEXT:    [[TMP28:%.*]] = insertelement <4 x i32> [[TMP26]], i32 [[TMP27]], i32 1
; SHADERTEST-NEXT:    [[TMP29:%.*]] = extractelement <4 x i32> [[TMP24]], i32 2
; SHADERTEST-NEXT:    [[TMP30:%.*]] = insertelement <4 x i32> [[TMP28]], i32 [[TMP29]], i32 2
; SHADERTEST-NEXT:    [[TMP31:%.*]] = extractelement <4 x i32> [[TMP24]], i32 3
; SHADERTEST-NEXT:    [[TMP32:%.*]] = insertelement <4 x i32> [[TMP30]], i32 [[TMP31]], i32 3
; SHADERTEST-NEXT:    [[VERTEX0_0:%.*]] = bitcast <4 x i32> [[TMP32]] to <4 x float>
; SHADERTEST-NEXT:    [[TMP33:%.*]] = extractelement <2 x float> [[VERTEX1_0]], i64 0
; SHADERTEST-NEXT:    [[TMP34:%.*]] = extractelement <2 x float> [[VERTEX1_0]], i64 1
; SHADERTEST-NEXT:    [[TMP35:%.*]] = extractelement <2 x float> [[VERTEX1_0]], i64 0
; SHADERTEST-NEXT:    [[TMP36:%.*]] = extractelement <2 x float> [[VERTEX1_0]], i64 1
; SHADERTEST-NEXT:    [[TMP37:%.*]] = insertelement <4 x float> poison, float [[TMP33]], i64 0
; SHADERTEST-NEXT:    [[TMP38:%.*]] = insertelement <4 x float> [[TMP37]], float [[TMP34]], i64 1
; SHADERTEST-NEXT:    [[TMP39:%.*]] = insertelement <4 x float> [[TMP38]], float [[TMP35]], i64 2
; SHADERTEST-NEXT:    [[TMP40:%.*]] = insertelement <4 x float> [[TMP39]], float [[TMP36]], i64 3
; SHADERTEST-NEXT:    call void @lgc.output.export.generic.i32.i32.v4f32(i32 0, i32 0, <4 x float> [[TMP40]]) #[[ATTR4:[0-9]+]]
; SHADERTEST-NEXT:    call void @lgc.output.export.builtin.Position.i32.v4f32(i32 0, <4 x float> [[VERTEX0_0]]) #[[ATTR4]]
; SHADERTEST-NEXT:    ret void
;
;
; SHADERTEST-LABEL: define {{[^@]+}}@lgc.shader.FS.main
; SHADERTEST-SAME: (i32 inreg noundef [[GLOBALTABLE:%.*]], i32 inreg noundef [[COMPOSITEDATA:%.*]], i32 inreg noundef [[PRIMMASK:%.*]], <2 x float> noundef [[PERSPINTERPSAMPLE:%.*]], <2 x float> noundef [[PERSPINTERPCENTER:%.*]], <2 x float> noundef [[PERSPINTERPCENTROID:%.*]], <3 x float> noundef [[PERSPINTERPPULLMODE:%.*]], <2 x float> noundef [[LINEARINTERPSAMPLE:%.*]], <2 x float> noundef [[LINEARINTERPCENTER:%.*]], <2 x float> noundef [[LINEARINTERPCENTROID:%.*]], float noundef [[LINESTIPPLE:%.*]], float noundef [[FRAGCOORDX:%.*]], float noundef [[FRAGCOORDY:%.*]], float noundef [[FRAGCOORDZ:%.*]], float noundef [[FRAGCOORDW:%.*]], i32 noundef [[FRONTFACING:%.*]], i32 noundef [[ANCILLARY:%.*]], i32 noundef [[SAMPLECOVERAGE:%.*]], i32 noundef [[FIXEDXY:%.*]]) #[[ATTR2:[0-9]+]] !spirv.ExecutionModel !16 !lgc.shaderstage !17 {
; SHADERTEST-NEXT:  .entry:
; SHADERTEST-NEXT:    [[INTERPPERSPSAMPLE:%.*]] = call <2 x float> @lgc.input.import.builtin.InterpPerspSample.v2f32.i32(i32 268435456) #[[ATTR5:[0-9]+]]
; SHADERTEST-NEXT:    [[TMP0:%.*]] = call float (...) @lgc.input.import.interpolated__f32(i1 false, i32 1, i32 0, i32 0, i32 poison, i32 0, <2 x float> [[INTERPPERSPSAMPLE]])
; SHADERTEST-NEXT:    [[TMP1:%.*]] = insertelement <2 x float> poison, float [[TMP0]], i64 0
; SHADERTEST-NEXT:    [[TMP2:%.*]] = call float (...) @lgc.input.import.interpolated__f32(i1 false, i32 1, i32 0, i32 1, i32 poison, i32 0, <2 x float> [[INTERPPERSPSAMPLE]])
; SHADERTEST-NEXT:    [[TMP3:%.*]] = insertelement <2 x float> [[TMP1]], float [[TMP2]], i64 1
; SHADERTEST-NEXT:    [[SAMPLEPOSITION:%.*]] = call <2 x float> @lgc.input.import.builtin.SamplePosition.v2f32.i32(i32 19) #[[ATTR5]]
; SHADERTEST-NEXT:    [[TMP4:%.*]] = fadd reassoc nnan nsz arcp contract afn <2 x float> [[SAMPLEPOSITION]], {{(splat \(float \-5\.000000e\-01\))|(<float \-5\.000000e\-01, float \-5\.000000e\-01>)}}
; SHADERTEST-NEXT:    [[TMP5:%.*]] = call reassoc nnan nsz arcp contract afn <2 x float> (...) @lgc.eval.Ij.offset.smooth__v2f32(<2 x float> [[TMP4]])
; SHADERTEST-NEXT:    [[TMP6:%.*]] = call float (...) @lgc.input.import.interpolated__f32(i1 false, i32 0, i32 0, i32 0, i32 poison, i32 0, <2 x float> [[TMP5]])
; SHADERTEST-NEXT:    [[TMP7:%.*]] = insertelement <2 x float> poison, float [[TMP6]], i64 0
; SHADERTEST-NEXT:    [[TMP8:%.*]] = call float (...) @lgc.input.import.interpolated__f32(i1 false, i32 0, i32 0, i32 1, i32 poison, i32 0, <2 x float> [[TMP5]])
; SHADERTEST-NEXT:    [[TMP9:%.*]] = insertelement <2 x float> [[TMP7]], float [[TMP8]], i64 1
; SHADERTEST-NEXT:    [[TMP10:%.*]] = fsub reassoc nnan nsz arcp contract afn <2 x float> [[TMP9]], [[TMP3]]
; SHADERTEST-NEXT:    [[TMP11:%.*]] = call reassoc nnan nsz arcp contract afn <2 x float> @llvm.fabs.v2f32(<2 x float> [[TMP10]])
; SHADERTEST-NEXT:    [[TMP12:%.*]] = extractelement <2 x float> [[TMP11]], i64 0
; SHADERTEST-NEXT:    [[TMP13:%.*]] = fcmp olt float [[TMP12]], 1.562500e-01
; SHADERTEST-NEXT:    [[TMP14:%.*]] = extractelement <2 x float> [[TMP11]], i64 1
; SHADERTEST-NEXT:    [[TMP15:%.*]] = fcmp olt float [[TMP14]], 1.562500e-01
; SHADERTEST-NEXT:    [[TMP16:%.*]] = and i1 [[TMP13]], [[TMP15]]
; SHADERTEST-NEXT:    [[COND_FREEZE:%.*]] = freeze i1 [[TMP16]]
; SHADERTEST-NEXT:    [[DOT:%.*]] = select i1 [[COND_FREEZE]], <4 x float> <float 0.000000e+00, float 1.000000e+00, float 0.000000e+00, float 1.000000e+00>, <4 x float> <float 1.000000e+00, float 0.000000e+00, float 0.000000e+00, float 1.000000e+00>
; SHADERTEST-NEXT:    [[TMP17:%.*]] = extractelement <4 x float> [[DOT]], i64 0
; SHADERTEST-NEXT:    [[TMP18:%.*]] = extractelement <4 x float> [[DOT]], i64 1
; SHADERTEST-NEXT:    [[TMP19:%.*]] = extractelement <4 x float> [[DOT]], i64 2
; SHADERTEST-NEXT:    [[TMP20:%.*]] = extractelement <4 x float> [[DOT]], i64 3
; SHADERTEST-NEXT:    [[TMP21:%.*]] = insertelement <4 x float> poison, float [[TMP17]], i64 0
; SHADERTEST-NEXT:    [[TMP22:%.*]] = insertelement <4 x float> [[TMP21]], float [[TMP18]], i64 1
; SHADERTEST-NEXT:    [[TMP23:%.*]] = insertelement <4 x float> [[TMP22]], float [[TMP19]], i64 2
; SHADERTEST-NEXT:    [[TMP24:%.*]] = insertelement <4 x float> [[TMP23]], float [[TMP20]], i64 3
; SHADERTEST-NEXT:    [[TMP25:%.*]] = extractelement <4 x float> [[TMP24]], i32 0
; SHADERTEST-NEXT:    [[TMP26:%.*]] = extractelement <4 x float> [[TMP24]], i32 1
; SHADERTEST-NEXT:    [[TMP27:%.*]] = extractelement <4 x float> [[TMP24]], i32 2
; SHADERTEST-NEXT:    [[TMP28:%.*]] = extractelement <4 x float> [[TMP24]], i32 3
; SHADERTEST-NEXT:    [[TMP29:%.*]] = call <2 x half> @llvm.amdgcn.cvt.pkrtz(float [[TMP25]], float [[TMP26]])
; SHADERTEST-NEXT:    [[TMP30:%.*]] = call <2 x half> @llvm.amdgcn.cvt.pkrtz(float [[TMP27]], float [[TMP28]])
; SHADERTEST-NEXT:    call void @llvm.amdgcn.exp.compr.v2f16(i32 0, i32 15, <2 x half> [[TMP29]], <2 x half> [[TMP30]], i1 true, i1 true)
; SHADERTEST-NEXT:    ret void
;
