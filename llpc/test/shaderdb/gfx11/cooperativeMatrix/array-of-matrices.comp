// NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
// RUN: amdllpc -o - -gfxip 11.0 -emit-lgc %s | FileCheck -check-prefixes=CHECK %s

#version 450 core
#pragma use_vulkan_memory_model
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set=0, binding=0, std430) buffer Buf { uvec4 x[]; } buf;

layout(push_constant) uniform PushConstants {
  int idx1;
  int idx2;
};

#define ELT_SIZE 16

void main() {
  coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseA> A[2];
  coopMatLoad(A[0], buf.x, 0, ELT_SIZE / 8, 0);
  coopMatLoad(A[1], buf.x, 32, ELT_SIZE / 8, 0);

  buf.x[0].x = uint(A[idx1][3]);

  coopMatStore(A[idx2], buf.x, 64, 4, 0);
}

// CHECK-LABEL:  @lgc.shader.CS.main(
// CHECK-LABEL:  .entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(4) (...) @lgc.create.load.push.constants.ptr.p4()
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(7) (...) @lgc.create.load.buffer.desc.p7(i64 0, i32 0, i32 0, i32 2)
// CHECK-NEXT:    [[TMP2:%.*]] = call <8 x float> @lgc.cooperative.matrix.load.v8f32.p7.i32.i1.i32.i32.i32(ptr addrspace(7) [[TMP1]], i32 32, i1 true, i32 1, i32 0, i32 0) #[[ATTR1:[0-9]+]]
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds <{ [4294967295 x [4 x i32]] }>, ptr addrspace(7) [[TMP1]], i32 0, i32 0, i32 32
// CHECK-NEXT:    [[TMP4:%.*]] = call <8 x float> @lgc.cooperative.matrix.load.v8f32.p7.i32.i1.i32.i32.i32(ptr addrspace(7) [[TMP3]], i32 32, i1 true, i32 1, i32 0, i32 0) #[[ATTR1]]
// CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(4) [[TMP0]], align 4
// CHECK-NEXT:    [[TMP6:%.*]] = icmp ult i32 [[TMP5]], 2
// CHECK-NEXT:    br i1 [[TMP6]], label %[[LABEL7:.*]], label %[[LABEL12:.*]]
// CHECK:       [[LABEL7]]:
// CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[TMP5]], 1
// CHECK-NEXT:    [[TMP9:%.*]] = select i1 [[TMP8]], <8 x float> [[TMP4]], <8 x float> [[TMP2]]
// CHECK-NEXT:    [[TMP10:%.*]] = call half @lgc.cooperative.matrix.extract.f16.v8f32.i32.i32.i32(<8 x float> [[TMP9]], i32 3, i32 1, i32 0) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    [[TMP11:%.*]] = fptoui half [[TMP10]] to i32
// CHECK-NEXT:    br label %[[LABEL12]]
// CHECK:       [[LABEL12]]:
// CHECK-NEXT:    [[TMP13:%.*]] = phi i32 [ 0, [[DOTENTRY:%.*]] ], [ [[TMP11]], %[[LABEL7]] ]
// CHECK-NEXT:    store i32 [[TMP13]], ptr addrspace(7) [[TMP1]], align 4
// CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds <{ i32, i32 }>, ptr addrspace(4) [[TMP0]], i64 0, i32 1
// CHECK-NEXT:    [[TMP15:%.*]] = load i32, ptr addrspace(4) [[TMP14]], align 4
// CHECK-NEXT:    [[TMP16:%.*]] = icmp ult i32 [[TMP15]], 2
// CHECK-NEXT:    [[TMP17:%.*]] = icmp eq i32 [[TMP15]], 1
// CHECK-NEXT:    [[TMP18:%.*]] = select i1 [[TMP17]], <8 x float> [[TMP4]], <8 x float> [[TMP2]]
// CHECK-NEXT:    [[TMP19:%.*]] = select i1 [[TMP16]], <8 x float> [[TMP18]], <8 x float> zeroinitializer
// CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds <{ [4294967295 x [4 x i32]] }>, ptr addrspace(7) [[TMP1]], i32 0, i32 0, i32 64
// CHECK-NEXT:    call void @lgc.cooperative.matrix.store.p7.i32.i1.i32.i32.i32.v8f32(ptr addrspace(7) [[TMP20]], i32 64, i1 true, i32 1, i32 0, i32 0, <8 x float> [[TMP19]]) #[[ATTR2:[0-9]+]]
// CHECK-NEXT:    ret void
//
