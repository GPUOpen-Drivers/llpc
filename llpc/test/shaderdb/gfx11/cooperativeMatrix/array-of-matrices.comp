// NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
// RUN: amdllpc -o - -gfxip 11.0 -emit-lgc %s | FileCheck -check-prefixes=CHECK %s

#version 450 core
#pragma use_vulkan_memory_model
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set=0, binding=0, std430) buffer Buf { uvec4 x[]; } buf;

layout(push_constant) uniform PushConstants {
  int idx1;
  int idx2;
};

#define ELT_SIZE 16

void main() {
  coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseA> A[2];
  coopMatLoad(A[0], buf.x, 0, ELT_SIZE / 8, 0);
  coopMatLoad(A[1], buf.x, 32, ELT_SIZE / 8, 0);

  buf.x[0].x = uint(A[idx1][3]);

  coopMatStore(A[idx2], buf.x, 64, 4, 0);
}

// CHECK-LABEL: @lgc.shader.CS.main(
// CHECK-NEXT:  .entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(4) (...) @lgc.create.load.push.constants.ptr.p4()
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(7) @lgc.load.buffer.desc(i64 0, i32 0, i32 0, i32 2)
// CHECK-NEXT:    [[LOAD:%.*]] = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr addrspace(7) [[TMP1]], i32 32, i1 true, i32 1, i32 0, i32 0, i32 16)
// CHECK-NEXT:    [[TMP2:%.*]] = getelementptr {{(inbounds )?}}i8, ptr addrspace(7) [[TMP1]], i32 512
// CHECK-NEXT:    [[LOAD2:%.*]] = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr addrspace(7) [[TMP2]], i32 32, i1 true, i32 1, i32 0, i32 0, i32 16)
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(4) [[TMP0]], align 4
// CHECK-NEXT:    [[TMP4:%.*]] = icmp ult i32 [[TMP3]], 2
// CHECK-NEXT:    br i1 [[TMP4]], label [[TMP5:%.*]], label [[TMP10:%.*]]
// CHECK:       5:
// CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i32 [[TMP3]], 1
// CHECK-NEXT:    [[TMP7:%.*]] = select i1 [[TMP6]], <8 x float> [[LOAD2]], <8 x float> [[LOAD]]
// CHECK-NEXT:    [[TMP8:%.*]] = call half (...) @lgc.cooperative.matrix.extract__f16(<8 x float> [[TMP7]], i32 3, i32 1, i32 0)
// CHECK-NEXT:    [[TMP9:%.*]] = fptoui half [[TMP8]] to i32
// CHECK-NEXT:    br label [[TMP10]]
// CHECK:       10:
// CHECK-NEXT:    [[TMP11:%.*]] = phi i32 [ 0, [[DOTENTRY:%.*]] ], [ [[TMP9]], [[TMP5]] ]
// CHECK-NEXT:    store i32 [[TMP11]], ptr addrspace(7) [[TMP1]], align 4
// CHECK-NEXT:    [[TMP12:%.*]] = getelementptr {{(inbounds )?}}i8, ptr addrspace(4) [[TMP0]], i64 4
// CHECK-NEXT:    [[TMP13:%.*]] = load i32, ptr addrspace(4) [[TMP12]], align 4
// CHECK-NEXT:    [[TMP14:%.*]] = icmp ult i32 [[TMP13]], 2
// CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[TMP13]], 1
// CHECK-NEXT:    [[TMP16:%.*]] = select i1 [[TMP15]], <8 x float> [[LOAD2]], <8 x float> [[LOAD]]
// CHECK-NEXT:    [[TMP17:%.*]] = select i1 [[TMP14]], <8 x float> [[TMP16]], <8 x float> zeroinitializer
// CHECK-NEXT:    [[TMP18:%.*]] = getelementptr {{(inbounds )?}}i8, ptr addrspace(7) [[TMP1]], i32 1024
// CHECK-NEXT:    call void (...) @lgc.cooperative.matrix.store(ptr addrspace(7) [[TMP18]], i32 64, i1 true, i32 1, i32 0, i32 0, i32 16, <8 x float> [[TMP17]])
// CHECK-NEXT:    ret void
//
