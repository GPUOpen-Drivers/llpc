// NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
// RUN: amdllpc -o - -gfxip 11.0 -emit-lgc %s | FileCheck -check-prefixes=CHECK %s

#version 450 core
#pragma use_vulkan_memory_model
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16: enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(set=0, binding=0, std430) buffer Buf { uvec4 x[]; } buf;

layout(push_constant) uniform PushConstants {
  int idx1;
  int idx2;
};

#define ELT_SIZE 16

void main() {
  coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseA> A[2];
  coopMatLoad(A[0], buf.x, 0, ELT_SIZE / 8, 0);
  coopMatLoad(A[1], buf.x, 32, ELT_SIZE / 8, 0);

  buf.x[0].x = uint(A[idx1][3]);

  coopMatStore(A[idx2], buf.x, 64, 4, 0);
}

// CHECK-LABEL: @lgc.shader.CS.main(
// CHECK-NEXT:  .entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(4) (...) @lgc.create.load.push.constants.ptr.p4()
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(7) @lgc.load.buffer.desc(i64 0, i32 0, i32 0, i32 2)
// CHECK-NEXT:    [[TMP2:%.*]] = call ptr addrspace(7) @lgc.buffer.index(ptr addrspace(7) [[TMP1]], i32 16, i32 0)
// CHECK-NEXT:    [[LOAD:%.*]] = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr addrspace(7) [[TMP2]], i32 32, i1 true, i32 1, i32 0, i32 0, i32 16, i32 16)
// CHECK-NEXT:    [[TMP3:%.*]] = call ptr addrspace(7) @lgc.buffer.index(ptr addrspace(7) [[TMP1]], i32 16, i32 32)
// CHECK-NEXT:    [[LOAD2:%.*]] = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr addrspace(7) [[TMP3]], i32 32, i1 true, i32 1, i32 0, i32 0, i32 16, i32 16)
// CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(4) [[TMP0]], align 4
// CHECK-NEXT:    [[TMP5:%.*]] = icmp ult i32 [[TMP4]], 2
// CHECK-NEXT:    br i1 [[TMP5]], label [[TMP6:%.*]], label [[TMP11:%.*]]
// CHECK:       6:
// CHECK-NEXT:    [[TMP7:%.*]] = icmp eq i32 [[TMP4]], 1
// CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TMP7]], <8 x float> [[LOAD2]], <8 x float> [[LOAD]]
// CHECK-NEXT:    [[TMP9:%.*]] = call half (...) @lgc.cooperative.matrix.extract__f16(<8 x float> [[TMP8]], i32 3, i32 1, i32 0)
// CHECK-NEXT:    [[TMP10:%.*]] = fptoui half [[TMP9]] to i32
// CHECK-NEXT:    br label [[TMP11]]
// CHECK:       11:
// CHECK-NEXT:    [[TMP12:%.*]] = phi i32 [ 0, [[DOTENTRY:%.*]] ], [ [[TMP10]], [[TMP6]] ]
// CHECK-NEXT:    store i32 [[TMP12]], ptr addrspace(7) [[TMP2]], align 4
// CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, ptr addrspace(4) [[TMP0]], i64 4
// CHECK-NEXT:    [[TMP14:%.*]] = load i32, ptr addrspace(4) [[TMP13]], align 4
// CHECK-NEXT:    [[TMP15:%.*]] = icmp ult i32 [[TMP14]], 2
// CHECK-NEXT:    [[TMP16:%.*]] = icmp eq i32 [[TMP14]], 1
// CHECK-NEXT:    [[TMP17:%.*]] = select i1 [[TMP16]], <8 x float> [[LOAD2]], <8 x float> [[LOAD]]
// CHECK-NEXT:    [[TMP18:%.*]] = select i1 [[TMP15]], <8 x float> [[TMP17]], <8 x float> zeroinitializer
// CHECK-NEXT:    [[TMP19:%.*]] = call ptr addrspace(7) @lgc.buffer.index(ptr addrspace(7) [[TMP1]], i32 16, i32 64)
// CHECK-NEXT:    call void (...) @lgc.cooperative.matrix.store(ptr addrspace(7) [[TMP19]], i32 64, i1 true, i32 1, i32 0, i32 0, i32 16, <8 x float> [[TMP18]], i32 16)
// CHECK-NEXT:    ret void
//
