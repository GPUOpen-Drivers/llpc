; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
; RUN: amdllpc -o - -gfxip 11.0 -emit-lgc %s | FileCheck -check-prefixes=CHECK %s

; SPIR-V
; Version: 1.6

; This test is derived from a simple compute shader compiled with glslang. It was hand-edited to use
; OpCooperativeMatrixLengthKHR as an instruction instead of a specialization constant.

               OpCapability Shader
               OpCapability Float16
               OpCapability VulkanMemoryModel
               OpCapability CooperativeMatrixKHR
               OpExtension "SPV_KHR_cooperative_matrix"
          %2 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical Vulkan
               OpEntryPoint GLCompute %main "main" %bufInA %bufInB %bufOut
               OpExecutionModeId %main LocalSizeId %uint_32 %uint_1 %uint_1
               OpDecorate %_runtimearr_v4uint ArrayStride 16
               OpMemberDecorate %InputA 0 Offset 0
               OpDecorate %InputA Block
               OpDecorate %bufInA DescriptorSet 0
               OpDecorate %bufInA Binding 0
               OpDecorate %_runtimearr_v4uint_0 ArrayStride 16
               OpMemberDecorate %InputB 0 Offset 0
               OpDecorate %InputB Block
               OpDecorate %bufInB DescriptorSet 0
               OpDecorate %bufInB Binding 1
               OpDecorate %_runtimearr_v4uint_1 ArrayStride 16
               OpMemberDecorate %Output 0 Offset 0
               OpDecorate %Output Block
               OpDecorate %bufOut DescriptorSet 0
               OpDecorate %bufOut Binding 2
       %void = OpTypeVoid
          %4 = OpTypeFunction %void
       %uint = OpTypeInt 32 0
    %uint_32 = OpConstant %uint 32
     %uint_1 = OpConstant %uint 1
       %half = OpTypeFloat 16
     %uint_3 = OpConstant %uint 3
    %uint_16 = OpConstant %uint 16
         %13 = OpTypeCooperativeMatrixKHR %half %uint_3 %uint_16 %uint_16 %uint_1
%_ptr_Function_13 = OpTypePointer Function %13
     %v4uint = OpTypeVector %uint 4
%_runtimearr_v4uint = OpTypeRuntimeArray %v4uint
     %InputA = OpTypeStruct %_runtimearr_v4uint
%_ptr_StorageBuffer_InputA = OpTypePointer StorageBuffer %InputA
     %bufInA = OpVariable %_ptr_StorageBuffer_InputA StorageBuffer
        %int = OpTypeInt 32 1
      %int_0 = OpConstant %int 0
     %uint_0 = OpConstant %uint 0
%_ptr_StorageBuffer_v4uint = OpTypePointer StorageBuffer %v4uint
     %uint_2 = OpConstant %uint 2
       %bool = OpTypeBool
      %false = OpConstantFalse %bool
%_runtimearr_v4uint_0 = OpTypeRuntimeArray %v4uint
     %InputB = OpTypeStruct %_runtimearr_v4uint_0
%_ptr_StorageBuffer_InputB = OpTypePointer StorageBuffer %InputB
     %bufInB = OpVariable %_ptr_StorageBuffer_InputB StorageBuffer
%_ptr_Function_int = OpTypePointer Function %int
%_ptr_Function_half = OpTypePointer Function %half
      %int_1 = OpConstant %int 1
%_runtimearr_v4uint_1 = OpTypeRuntimeArray %v4uint
     %Output = OpTypeStruct %_runtimearr_v4uint_1
%_ptr_StorageBuffer_Output = OpTypePointer StorageBuffer %Output
     %bufOut = OpVariable %_ptr_StorageBuffer_Output StorageBuffer
     %uint_4 = OpConstant %uint 4
     %v3uint = OpTypeVector %uint 3
         %74 = OpConstantComposite %v3uint %uint_32 %uint_1 %uint_1
       %main = OpFunction %void None %4
          %6 = OpLabel
    %tempArg = OpVariable %_ptr_Function_13 Function
          %A = OpVariable %_ptr_Function_13 Function
  %tempArg_0 = OpVariable %_ptr_Function_13 Function
          %B = OpVariable %_ptr_Function_13 Function
          %i = OpVariable %_ptr_Function_int Function
          %C = OpVariable %_ptr_Function_13 Function
         %25 = OpAccessChain %_ptr_StorageBuffer_v4uint %bufInA %int_0 %uint_0
         %29 = OpCooperativeMatrixLoadKHR %13 %25 %uint_1 %uint_2 None
               OpStore %tempArg %29
         %31 = OpLoad %13 %tempArg
               OpStore %A %31
         %37 = OpAccessChain %_ptr_StorageBuffer_v4uint %bufInB %int_0 %uint_0
         %38 = OpCooperativeMatrixLoadKHR %13 %37 %uint_1 %uint_2 None
               OpStore %tempArg_0 %38
         %40 = OpLoad %13 %tempArg_0
               OpStore %B %40
               OpStore %i %int_0
               OpBranch %43
         %43 = OpLabel
               OpLoopMerge %45 %46 Unroll
               OpBranch %47
         %47 = OpLabel
         %48 = OpLoad %int %i
         %50 = OpCooperativeMatrixLengthKHR %uint %13
         %51 = OpSLessThan %bool %48 %50
               OpBranchConditional %51 %44 %45
         %44 = OpLabel
         %53 = OpLoad %int %i
         %54 = OpLoad %int %i
         %56 = OpAccessChain %_ptr_Function_half %A %54
         %57 = OpLoad %half %56
         %58 = OpLoad %int %i
         %59 = OpAccessChain %_ptr_Function_half %B %58
         %60 = OpLoad %half %59
         %61 = OpFMul %half %57 %60
         %62 = OpAccessChain %_ptr_Function_half %C %53
               OpStore %62 %61
               OpBranch %46
         %46 = OpLabel
         %63 = OpLoad %int %i
         %65 = OpIAdd %int %63 %int_1
               OpStore %i %65
               OpBranch %43
         %45 = OpLabel
         %66 = OpLoad %13 %C
         %71 = OpAccessChain %_ptr_StorageBuffer_v4uint %bufOut %int_0 %uint_0
               OpCooperativeMatrixStoreKHR %71 %66 %uint_1 %uint_4 None
               OpReturn
               OpFunctionEnd

; CHECK-LABEL: @lgc.shader.CS.main(
; CHECK-NEXT:  .entry:
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(7) @lgc.load.buffer.desc(i64 0, i32 1, i32 0, i32 2)
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(7) @lgc.load.buffer.desc(i64 0, i32 0, i32 0, i32 2)
; CHECK-NEXT:    [[LOAD:%.*]] = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr addrspace(7) [[TMP1]], i32 32, i1 true, i32 1, i32 0, i32 0, i32 16)
; CHECK-NEXT:    [[LOAD1:%.*]] = call <8 x float> (...) @lgc.cooperative.matrix.load__v8f32(ptr addrspace(7) [[TMP0]], i32 32, i1 true, i32 1, i32 0, i32 0, i32 16)
; CHECK-NEXT:    br label [[TMP2:%.*]]
; CHECK:       2:
; CHECK-NEXT:    [[DOT012:%.*]] = phi i32 [ 0, [[DOTENTRY:%.*]] ], [ [[TMP10:%.*]], [[TMP5:%.*]] ]
; CHECK-NEXT:    [[DOT0:%.*]] = phi <8 x float> [ undef, [[DOTENTRY]] ], [ [[TMP9:%.*]], [[TMP5]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = call i32 @lgc.cooperative.matrix.length(i32 0)
; CHECK-NEXT:    [[TMP4:%.*]] = icmp slt i32 [[DOT012]], [[TMP3]]
; CHECK-NEXT:    [[COND_FREEZE:%.*]] = freeze i1 [[TMP4]]
; CHECK-NEXT:    br i1 [[COND_FREEZE]], label [[TMP5]], label [[TMP11:%.*]]
; CHECK:       5:
; CHECK-NEXT:    [[TMP6:%.*]] = call half (...) @lgc.cooperative.matrix.extract__f16(<8 x float> [[LOAD]], i32 [[DOT012]], i32 1, i32 0)
; CHECK-NEXT:    [[TMP7:%.*]] = call half (...) @lgc.cooperative.matrix.extract__f16(<8 x float> [[LOAD1]], i32 [[DOT012]], i32 1, i32 0)
; CHECK-NEXT:    [[TMP8:%.*]] = fmul reassoc nnan nsz arcp contract afn half [[TMP6]], [[TMP7]]
; CHECK-NEXT:    [[TMP9]] = call <8 x float> (...) @lgc.cooperative.matrix.insert__v8f32(<8 x float> [[DOT0]], half [[TMP8]], i32 [[DOT012]], i32 1, i32 0)
; CHECK-NEXT:    [[TMP10]] = add i32 [[DOT012]], 1
; CHECK-NEXT:    br label [[TMP2]], !llvm.loop [[LOOP12:![0-9]+]]
; CHECK:       11:
; CHECK-NEXT:    [[TMP12:%.*]] = call ptr addrspace(7) @lgc.load.buffer.desc(i64 0, i32 2, i32 0, i32 2)
; CHECK-NEXT:    call void (...) @lgc.cooperative.matrix.store(ptr addrspace(7) [[TMP12]], i32 64, i1 true, i32 1, i32 0, i32 0, i32 16, <8 x float> [[DOT0]])
; CHECK-NEXT:    ret void
;
