/*
 ***********************************************************************************************************************
 *
 *  Copyright (c) 2024-2025 Advanced Micro Devices, Inc. All Rights Reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 *
 **********************************************************************************************************************/

// NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py
// RUN: amdllpc --print-after=lower-translator -filetype=asm -o - 2>&1 %s | FileCheck -check-prefixes=SHADERTEST %s
#version 450 core

layout(std430, binding = 0) buffer Block
{
    vec4   base;
    vec4   o[];
} block;

layout(set = 1, binding = 0, row_major) buffer Block2
{
    mat4x2 m4x2;
    float f[];
} data[3];

void main()
{
    block.o[gl_VertexIndex] = block.base + vec4(gl_VertexIndex);

    gl_Position = vec4(data[1].m4x2[0][0], 0.0, 0.0, 1.0);
}

// SHADERTEST-LABEL: @main(
// SHADERTEST-NEXT:  .entry:
// SHADERTEST-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(64) @gl_VertexIndex, align 4
// SHADERTEST-NEXT:    [[TMP1:%.*]] = load <4 x float>, ptr addrspace(7) @block, align 16
// SHADERTEST-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(64) @gl_VertexIndex, align 4
// SHADERTEST-NEXT:    [[TMP3:%.*]] = sitofp i32 [[TMP2]] to float
// SHADERTEST-NEXT:    [[TMP4:%.*]] = insertelement <4 x float> poison, float [[TMP3]], i32 0
// SHADERTEST-NEXT:    [[TMP5:%.*]] = insertelement <4 x float> [[TMP4]], float [[TMP3]], i32 1
// SHADERTEST-NEXT:    [[TMP6:%.*]] = insertelement <4 x float> [[TMP5]], float [[TMP3]], i32 2
// SHADERTEST-NEXT:    [[TMP7:%.*]] = insertelement <4 x float> [[TMP6]], float [[TMP3]], i32 3
// SHADERTEST-NEXT:    [[TMP8:%.*]] = fadd reassoc nnan nsz arcp contract afn <4 x float> [[TMP1]], [[TMP7]]
// SHADERTEST-NEXT:    [[TMP9:%.*]] = call ptr addrspace(7) @lgc.buffer.index(ptr addrspace(7) getelementptr (<{ [4 x float], [0 x [4 x float]] }>, ptr addrspace(7) @block, i32 0, i32 1), i32 16, i32 [[TMP0]])
// SHADERTEST-NEXT:    store <4 x float> [[TMP8]], ptr addrspace(7) [[TMP9]], align 16
// SHADERTEST-NEXT:    [[TMP10:%.*]] = load float, ptr addrspace(7) getelementptr ([3 x <{ [2 x %llpc.matrix.row], [0 x float] }>], ptr addrspace(7) @data, i32 0, i32 1, i32 0), align 4
// SHADERTEST-NEXT:    [[TMP11:%.*]] = insertelement <4 x float> poison, float [[TMP10]], i32 0
// SHADERTEST-NEXT:    [[TMP12:%.*]] = insertelement <4 x float> [[TMP11]], float 0.000000e+00, i32 1
// SHADERTEST-NEXT:    [[TMP13:%.*]] = insertelement <4 x float> [[TMP12]], float 0.000000e+00, i32 2
// SHADERTEST-NEXT:    [[TMP14:%.*]] = insertelement <4 x float> [[TMP13]], float 1.000000e+00, i32 3
// SHADERTEST-NEXT:    [[TMP15:%.*]] = call ptr addrspace(65) (...) @llpc.structural.gep__p65(ptr addrspace(65) @[[GLOB0:[0-9]+]], { <4 x float>, float, [1 x float], [1 x float] } poison, i1 false, i32 0, i32 0)
// SHADERTEST-NEXT:    store <4 x float> [[TMP14]], ptr addrspace(65) [[TMP15]], align 16
// SHADERTEST-NEXT:    ret void
//
