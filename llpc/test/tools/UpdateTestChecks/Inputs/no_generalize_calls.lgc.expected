; NOTE: Assertions have been autogenerated by tool/update_llpc_test_checks.py UTC_ARGS: --tool lgc --version 5
; Test that invalid image descriptor patching is applied where required.

; RUN: lgc -mcpu=gfx1010 -passes=lgc-apply-workarounds -o - - <%s 2>&1 | FileCheck --check-prefixes=CHECK,GFX1010 %s

;; Copyright (c) 2025 Advanced Micro Devices, Inc. All Rights Reserved. ;;


; ModuleID = 'lgcPipeline'
source_filename = "lgcPipeline"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-ni:7"
target triple = "amdgcn--amdpal"

; Function Attrs: nounwind
define dllexport spir_func void @lgc.shader.VS.main() local_unnamed_addr #0 !lgc.shaderstage !0 {
.entry:
  %.desc.ptr2 = call <8 x i32> addrspace(4)* (...) @lgc.create.get.desc.ptr.p4v8i32(i32 1, i32 1, i32 3, i32 3)
  %.desc.ptr1 = bitcast <8 x i32> addrspace(4)* %.desc.ptr2 to i8 addrspace(4)*
  %.desc.ptr0 = getelementptr i8, i8 addrspace(4)* %.desc.ptr1, i64 0
  %.desc.ptr = bitcast i8 addrspace(4)* %.desc.ptr0 to <8 x i32> addrspace(4)*
  %.sampler.ptr = call <4 x i32> addrspace(4)* (...) @lgc.create.get.desc.ptr.p4v4i32(i32 2, i32 2, i32 0, i32 13)

  %.load = call <4 x float> (...) @lgc.create.image.load.v4f32(i32 0, i32 128, <8 x i32> addrspace(4)* %.desc.ptr, i32 1)
  call void (...) @lgc.create.image.store(<4 x float> zeroinitializer, i32 1, i32 128, <8 x i32> addrspace(4)* %.desc.ptr, <2 x i32> zeroinitializer)

  %.sample = call <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 128, <8 x i32> addrspace(4)* %.desc.ptr, <4 x i32> addrspace(4)* %.sampler.ptr, i32 1, <2 x float> zeroinitializer)
  %.gather = call <4 x float> (...) @lgc.create.image.gather.v4f32(i32 1, i32 128, <8 x i32> addrspace(4)* %.desc.ptr, <4 x i32> addrspace(4)* %.sampler.ptr, i32 37, <2 x float> zeroinitializer, i32 0, float 0.000000e+00)

  %.atomic = call i32 (...) @lgc.create.image.atomic.i32(i32 2, i32 0, i32 128, i32 0, <8 x i32> addrspace(4)* %.desc.ptr, i32 0, i32 1) #0

  %.lod = call <2 x float> (...) @lgc.create.image.get.lod.v2f32(i32 1, i32 128, <8 x i32> addrspace(4)* %.desc.ptr, <4 x i32> addrspace(4)* %.sampler.ptr, <2 x float> zeroinitializer)

  %.query.size = call <2 x i32> (...) @lgc.create.image.query.size.v2i32(i32 1, i32 128, <8 x i32> addrspace(4)* %.desc.ptr, i32 0)
  %.query.levels = call i32 (...) @lgc.create.image.query.levels.i32(i32 1, i32 128, <8 x i32> addrspace(4)* %.desc.ptr)

  %lane = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)  ; just some source of divergence
  %ofs = mul i32 %lane, 32

  ; Use a waterfall loop with last.use to test that is also handled correctly
  %.desc2.ptr2 = call <8 x i32> addrspace(4)* (...) @lgc.create.get.desc.ptr.p4v8i32(i32 1, i32 1, i32 3, i32 4)
  %.desc2.ptr1 = bitcast <8 x i32> addrspace(4)* %.desc2.ptr2 to i8 addrspace(4)*
  %.desc2.ptr0 = getelementptr i8, i8 addrspace(4)* %.desc2.ptr1, i32 %ofs
  %.desc2.ptr = bitcast i8 addrspace(4)* %.desc2.ptr0 to <8 x i32> addrspace(4)*
  call void (...) @lgc.create.image.store(<4 x float> zeroinitializer, i32 0, i32 8, <8 x i32> addrspace(4)* %.desc2.ptr, i32 zeroinitializer)

  ret void
}

declare <8 x i32> addrspace(4)* @lgc.create.get.desc.ptr.p4v8i32(...) #1
declare <4 x i32> addrspace(4)* @lgc.create.get.desc.ptr.p4v4i32(...) #1
declare <4 x float> @lgc.create.image.load.v4f32(...) #1
declare void @lgc.create.image.store(...) #2
declare <4 x float> @lgc.create.image.sample.v4f32(...) #1
declare <4 x float> @lgc.create.image.gather.v4f32(...) #1
declare i32 @lgc.create.image.atomic.i32(...) #0
declare <2 x float> @lgc.create.image.get.lod.v2f32(...) #0
declare <2 x i32> @lgc.create.image.query.size.v2i32(...) #0
declare i32 @lgc.create.image.query.levels.i32(...) #0

declare i32 @llvm.amdgcn.mbcnt.lo(i32, i32)

attributes #0 = { nounwind }
attributes #1 = { nounwind readonly }
attributes #2 = { nounwind writeonly }

!0 = !{i32 1}

!lgc.unlinked = !{!0}
!lgc.user.data.nodes = !{!1,!2,!3,!4}

!1 = !{!"DescriptorTableVaPtr", i32 0, i32 0, i32 0, i32 1, i32 3}
!2 = !{!"DescriptorResource", i32 1, i32 0, i32 0, i32 8, i32 3, i32 3, i32 8}
!3 = !{!"DescriptorResource", i32 1, i32 0, i32 8, i32 8, i32 3, i32 4, i32 8}
!4 = !{!"DescriptorSampler", i32 2, i32 0, i32 16, i32 4, i32 0, i32 13, i32 4}
; CHECK-LABEL: define dllexport spir_func void @lgc.shader.VS.main(
; CHECK-SAME: ) local_unnamed_addr #[[ATTR0:[0-9]+]] !lgc.shaderstage [[META0:![0-9]+]] {
; CHECK-NEXT:  [[_ENTRY:.*:]]
; CHECK-NEXT:    [[DOTDESC_PTR2:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4v8i32(i32 1, i32 1, i32 3, i32 3)
; CHECK-NEXT:    [[DOTDESC_PTR1:%.*]] = bitcast ptr addrspace(4) [[DOTDESC_PTR2]] to ptr addrspace(4)
; CHECK-NEXT:    [[DOTDESC_PTR0:%.*]] = getelementptr i8, ptr addrspace(4) [[DOTDESC_PTR1]], i64 0
; CHECK-NEXT:    [[DOTDESC_PTR:%.*]] = bitcast ptr addrspace(4) [[DOTDESC_PTR0]] to ptr addrspace(4)
; CHECK-NEXT:    [[DOTSAMPLER_PTR:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4v4i32(i32 2, i32 2, i32 0, i32 13)
; CHECK-NEXT:    [[DOTLOAD:%.*]] = call <4 x float> (...) @lgc.create.image.load.v4f32(i32 0, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], i32 1)
; CHECK-NEXT:    call void (...) @lgc.create.image.store(<4 x float> zeroinitializer, i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], <2 x i32> zeroinitializer)
; CHECK-NEXT:    [[DOTSAMPLE:%.*]] = call <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], ptr addrspace(4) [[DOTSAMPLER_PTR]], i32 1, <2 x float> zeroinitializer)
; CHECK-NEXT:    [[DOTGATHER:%.*]] = call <4 x float> (...) @lgc.create.image.gather.v4f32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], ptr addrspace(4) [[DOTSAMPLER_PTR]], i32 37, <2 x float> zeroinitializer, i32 0, float 0.000000e+00)
; CHECK-NEXT:    [[DOTATOMIC:%.*]] = call i32 (...) @lgc.create.image.atomic.i32(i32 2, i32 0, i32 128, i32 0, ptr addrspace(4) [[DOTDESC_PTR]], i32 0, i32 1) #[[ATTR0]]
; CHECK-NEXT:    [[DOTLOD:%.*]] = call <2 x float> (...) @lgc.create.image.get.lod.v2f32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], ptr addrspace(4) [[DOTSAMPLER_PTR]], <2 x float> zeroinitializer)
; CHECK-NEXT:    [[DOTQUERY_SIZE:%.*]] = call <2 x i32> (...) @lgc.create.image.query.size.v2i32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], i32 0)
; CHECK-NEXT:    [[DOTQUERY_LEVELS:%.*]] = call i32 (...) @lgc.create.image.query.levels.i32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]])
; CHECK-NEXT:    [[LANE:%.*]] = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
; CHECK-NEXT:    [[OFS:%.*]] = mul i32 [[LANE]], 32
; CHECK-NEXT:    [[DOTDESC2_PTR2:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4v8i32(i32 1, i32 1, i32 3, i32 4)
; CHECK-NEXT:    [[DOTDESC2_PTR1:%.*]] = bitcast ptr addrspace(4) [[DOTDESC2_PTR2]] to ptr addrspace(4)
; CHECK-NEXT:    [[DOTDESC2_PTR0:%.*]] = getelementptr i8, ptr addrspace(4) [[DOTDESC2_PTR1]], i32 [[OFS]]
; CHECK-NEXT:    [[DOTDESC2_PTR:%.*]] = bitcast ptr addrspace(4) [[DOTDESC2_PTR0]] to ptr addrspace(4)
; CHECK-NEXT:    call void (...) @lgc.create.image.store(<4 x float> zeroinitializer, i32 0, i32 8, ptr addrspace(4) [[DOTDESC2_PTR]], i32 0)
; CHECK-NEXT:    ret void
;
;
; GFX1010-LABEL: define dllexport spir_func void @lgc.shader.VS.main(
; GFX1010-SAME: ) local_unnamed_addr #[[ATTR0:[0-9]+]] !lgc.shaderstage [[META0:![0-9]+]] {
; GFX1010-NEXT:  [[_ENTRY:.*:]]
; GFX1010-NEXT:    [[DOTDESC_PTR2:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4v8i32(i32 1, i32 1, i32 3, i32 3)
; GFX1010-NEXT:    [[DOTDESC_PTR1:%.*]] = bitcast ptr addrspace(4) [[DOTDESC_PTR2]] to ptr addrspace(4)
; GFX1010-NEXT:    [[DOTDESC_PTR0:%.*]] = getelementptr i8, ptr addrspace(4) [[DOTDESC_PTR1]], i64 0
; GFX1010-NEXT:    [[DOTDESC_PTR:%.*]] = bitcast ptr addrspace(4) [[DOTDESC_PTR0]] to ptr addrspace(4)
; GFX1010-NEXT:    [[DOTSAMPLER_PTR:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4v4i32(i32 2, i32 2, i32 0, i32 13)
; GFX1010-NEXT:    [[DOTLOAD:%.*]] = call <4 x float> (...) @lgc.create.image.load.v4f32(i32 0, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], i32 1)
; GFX1010-NEXT:    call void (...) @lgc.create.image.store(<4 x float> zeroinitializer, i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], <2 x i32> zeroinitializer)
; GFX1010-NEXT:    [[DOTSAMPLE:%.*]] = call <4 x float> (...) @lgc.create.image.sample.v4f32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], ptr addrspace(4) [[DOTSAMPLER_PTR]], i32 1, <2 x float> zeroinitializer)
; GFX1010-NEXT:    [[DOTGATHER:%.*]] = call <4 x float> (...) @lgc.create.image.gather.v4f32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], ptr addrspace(4) [[DOTSAMPLER_PTR]], i32 37, <2 x float> zeroinitializer, i32 0, float 0.000000e+00)
; GFX1010-NEXT:    [[DOTATOMIC:%.*]] = call i32 (...) @lgc.create.image.atomic.i32(i32 2, i32 0, i32 128, i32 0, ptr addrspace(4) [[DOTDESC_PTR]], i32 0, i32 1) #[[ATTR0]]
; GFX1010-NEXT:    [[DOTLOD:%.*]] = call <2 x float> (...) @lgc.create.image.get.lod.v2f32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], ptr addrspace(4) [[DOTSAMPLER_PTR]], <2 x float> zeroinitializer)
; GFX1010-NEXT:    [[DOTQUERY_SIZE:%.*]] = call <2 x i32> (...) @lgc.create.image.query.size.v2i32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]], i32 0)
; GFX1010-NEXT:    [[DOTQUERY_LEVELS:%.*]] = call i32 (...) @lgc.create.image.query.levels.i32(i32 1, i32 128, ptr addrspace(4) [[DOTDESC_PTR]])
; GFX1010-NEXT:    [[LANE:%.*]] = call i32 @llvm.amdgcn.mbcnt.lo(i32 -1, i32 0)
; GFX1010-NEXT:    [[OFS:%.*]] = mul i32 [[LANE]], 32
; GFX1010-NEXT:    [[DOTDESC2_PTR2:%.*]] = call ptr addrspace(4) (...) @lgc.create.get.desc.ptr.p4v8i32(i32 1, i32 1, i32 3, i32 4)
; GFX1010-NEXT:    [[DOTDESC2_PTR1:%.*]] = bitcast ptr addrspace(4) [[DOTDESC2_PTR2]] to ptr addrspace(4)
; GFX1010-NEXT:    [[DOTDESC2_PTR0:%.*]] = getelementptr i8, ptr addrspace(4) [[DOTDESC2_PTR1]], i32 [[OFS]]
; GFX1010-NEXT:    [[DOTDESC2_PTR:%.*]] = bitcast ptr addrspace(4) [[DOTDESC2_PTR0]] to ptr addrspace(4)
; GFX1010-NEXT:    call void (...) @lgc.create.image.store(<4 x float> zeroinitializer, i32 0, i32 8, ptr addrspace(4) [[DOTDESC2_PTR]], i32 0)
; GFX1010-NEXT:    ret void
;
;.
; CHECK: [[META0]] = !{i32 1}
;.
