/*
 ***********************************************************************************************************************
 *
 *  Copyright (c) 2023-2025 Advanced Micro Devices, Inc. All Rights Reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 *
 **********************************************************************************************************************/

// lgc.rt dialect definition: ops for ray-tracing that are generated by language readers and lowered in the
// ray-tracing lowering passes.
//
// In addition to the ops defined here, this dialect defines certain properties of shaders:
//
// * A ray-tracing shader has its shader stage set using lgc::rt::setLgcRtShaderStage. You can use
//   lgc::rt::getLgcRtShaderStage to get the marked shader stage back. The client is responsible for
//   translating the enum value back as required.
//
// * A ray-tracing shader returns void, and takes 0, 1 or 2 pointer args (private address space) as appropriate:
//   - rayGen: 0 args
//   - intersection: 0 args
//   - anyHit: payload and optional hit attribute
//   - closestHit: payload and optional hit attribute
//   - miss: payload
//   - callable: callable data
//
// * A shader with a payload arg has a metadata item giving the PAQ (payload access qualifier); you set and
//   get that with setShaderPaq() and getShaderPaq() functions in LgcRtDialect.h. A PAQ is a constant array
//   of ints; currently the only supported form is a single-entry array where the value is the size in bytes
//   of the payload. This is the same form of PAQ that is passed as an arg to TraceRayOp.
//   A pipeline-wide upper bound on the payload size in bytes can be accessed via getMaxPayloadSize() and
//   getMaxPayloadSize().
//
// * A shader with a hit attribute arg has a metadata item giving the hit attribute size in bytes,
//   which is guaranteed to be not larger than the pipeline-wide max hit attribute size.
//   The per-shader hit attribute size is accessed using setShaderHitAttributeSize() and
//   getHitShaderAttributeSize() in LgcRtDialect.h.
//   The pipeline-wide maximum sizes can be accessed accessed using getMaxHitAttributeSize()
//   and setMaxHitAttributeSize().
//
// * A callable shader has a metadata item giving the callable data size in bytes; that is set and got using
//   setShaderArgSize() and getShaderArgSize() in LgcRtDialect.h.

include "llvm-dialects/Dialect/Dialect.td"

def LgcRtDialect : Dialect {
  let name = "lgc.rt";
  let cppNamespace = "lgc::rt";
}

def V3F32 : TgConstant<(FixedVectorType F32, 3)>, Type;
def V3I32 : TgConstant<(FixedVectorType I32, 3)>, Type;
def A4V3F32 : TgConstant<(ArrayType V3F32, 4)>, Type;
def A3V3F32 : TgConstant<(ArrayType V3F32, 3)>, Type;
def I126 : TgConstant<(IntegerType 126)>, Type;

def GlobalPointer : TgConstant<(PointerType 1)>, Type;
def PrivatePointer : TgConstant<(PointerType 5)>, Type;

class LgcRtOp<string mnemonic_, list<Trait> traits_ = []>
    : Op<LgcRtDialect, mnemonic_, traits_ # [NoUnwind]>;

// =========================================================================================================
def AcceptHitAndEndSearchOp : LgcRtOp<"accept.hit.and.end.search", [Memory<[(write InaccessibleMem)]>, NoReturn]> {
  let arguments = (ins);
  let results = (outs);

  let summary = "Accept a hit in an anyHit shader";
  let description = [{
    Used in an anyHit shader to accept the current hit and stop searching for more hits. The intersection
    shader that caused this anyHit shader to run (if any) will exit, and execution will pass to the
    closestHit shader if any.
  }];
}

// =========================================================================================================
def CallCallableShaderOp : LgcRtOp<"call.callable.shader", [Memory<[(readwrite InaccessibleMem), (readwrite ArgMem)]>, WillReturn]> {
  let arguments = (ins I32:$shader_index, PointerType:$param, AttrI32:$param_data_size_bytes);
  let results = (outs);

  let summary = "Call a ray-tracing callable shader";
  let description = [{
    Call the ray-tracing callable shader at the specified index in the callable shader table,
    passing the parameter in and out. $param_data_size_bytes refers to the size of the data
    pointed to by $param, given in bytes.
  }];
}

// =========================================================================================================
def DispatchRaysDimensionsOp : LgcRtOp<"dispatch.rays.dimensions", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3I32:$result);

  let summary = "Return the dispatchRays dimensions";
  let description = [{
    Return a <3 x i32> vector giving the X,Y,Z dimensions of the dispatchRays.
  }];
}

// =========================================================================================================
def DispatchRaysIndexOp : LgcRtOp<"dispatch.rays.index", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3I32:$result);

  let summary = "Return the dispatchRays index";
  let description = [{
    Return a <3 x i32> vector giving the X,Y,Z index of the current ray in the dispatchRays.
  }];
}

// =========================================================================================================
def GeometryIndexOp : LgcRtOp<"geometry.index", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);

  let summary = "Return the geometry index";
  let description = [{
    Return an i32 giving the geometry index.
  }];
}

// =========================================================================================================
def HitKindOp : LgcRtOp<"hit.kind", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);

  let summary = "Return the hit kind";
  let description = [{
    Return an i32 giving the hit kind passed in to ReportHit. For a fixed-function triangle intersection,
    it is 254 for front-facing or 255 for back-facing.
  }];
}

// =========================================================================================================
def IgnoreHitOp : LgcRtOp<"ignore.hit", [Memory<[(write InaccessibleMem)]>, NoReturn]> {
  let arguments = (ins);
  let results = (outs);

  let summary = "Ignore a hit in an anyHit shader";
  let description = [{
    Used in an anyHit shader to reject the hit and end the shader. The ReportHitOp in the intersection
    shader that caused this anyHit shader to run will return false.
  }];
}

// =========================================================================================================
def InstanceIdOp : LgcRtOp<"instance.id", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);

  let summary = "Return the instance ID";
  let description = [{
    Return an i32 giving the user-provided instance ID on the bottom-level acceleration structure instance
    within the top-level structure.
  }];
}

// =========================================================================================================
def InstanceIndexOp : LgcRtOp<"instance.index", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);

  let summary = "Return the instance index";
  let description = [{
    Return an i32 giving the autogenerated index of the current instance in the top-level structure.
  }];
}

// =========================================================================================================
def ObjectRayDirectionOp : LgcRtOp<"object.ray.direction", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs V3F32:$result);

  let summary = "Return the object-space direction";
  let description = [{
    Return a <3 x float> vector giving the object-space direction for the current ray.
  }];
}

// =========================================================================================================
def ObjectRayOriginOp : LgcRtOp<"object.ray.origin", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs V3F32:$result);

  let summary = "Return the object-space origin";
  let description = [{
    Return a <3 x float> vector giving the object-space origin for the current ray.
  }];
}

// =========================================================================================================
def ObjectToWorldOp : LgcRtOp<"object.to.world", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs A4V3F32:$result);

  let summary = "Return the current object-to-world transformation matrix";
  let description = [{
    Return a [4 x <3 x float>] matrix (array-of-vectors) giving the object-to-world transformation
    matrix for the current intersection.
  }];
}

// =========================================================================================================
def PrimitiveIndexOp : LgcRtOp<"primitive.index", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);

  let summary = "Return the primitive index";
  let description = [{
    Return an i32 giving the primitive index.
  }];
}

// =========================================================================================================
def RayFlagsOp : LgcRtOp<"ray.flags", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);

  let summary = "Return the current ray flags";
  let description = [{
    Return an i32 giving the current ray flags.
  }];
}

// =========================================================================================================
def RayTcurrentOp : LgcRtOp<"ray.tcurrent", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs F32:$result);

  let summary = "Return the current parametric ending point for the ray";
  let description = [{
    Return a float giving the current parametric ending point for the ray.
  }];
}

// =========================================================================================================
def RayTminOp : LgcRtOp<"ray.tmin", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs F32:$result);

  let summary = "Return the parametric starting point for the ray";
  let description = [{
    Return a float giving the parametric starting point for the ray.
  }];
}

// =========================================================================================================
def ReportHitOp : LgcRtOp<"report.hit", [Memory<[(write InaccessibleMem), (read ArgMem)]>]> {
  let arguments = (ins F32:$thit, I32:$hit_kind, PointerType:$attributes, AttrI32:$size);
  let results = (outs I1:$result);

  let summary = "Report a hit in an intersection shader";
  let description = [{
    Report a hit in an intersection shader, returning true if the hit was accepted. A hit is rejected
    if thit is outside the current ray interval or if the anyHit shader calls IgnoreHitOp.

    - thit: Parametric distance of the intersection.

    - hit_kind: User-specified hit kind in the range 0-127, visible to anyHit and closestHit shaders using
      HitKindOp.

    - attributes: User-defined intersection attributes.

    - size: Size of the data pointed to by attributes (in bytes)
  }];
}

// =========================================================================================================
def ShaderIndexOp : LgcRtOp<"shader.index", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the current shader index";
  let description = [{
    Return the current shader index.

    The shader index is used to index into the shader binding table, i.e. the table which backs the
    Vulkan shader record buffers or the DX12 local root signatures.
  }];
}

// =========================================================================================================
def ShaderRecordBufferOp : LgcRtOp<"shader.record.buffer", [Memory<[]>, WillReturn]> {
  let arguments = (ins I32:$shader_index);
  let results = (outs GlobalPointer:$ptr);

  let summary = "Return the pointer to shader record buffer";
  let description = [{
    Return the pointer to shader record buffer.

    - shader_index: The value used to index into the shader binding table.
  }];
}

// =========================================================================================================
def BaseTraceRayOp : OpClass<LgcRtDialect> {
  let arguments = (ins I64:$accel_struct, I32:$ray_flags, I32:$instance_inclusion_mask,
      I32:$ray_contribution_to_hit_group_index, I32:$multiplier_for_geometry_contribution, I32:$miss_shader_index,
      V3F32:$origin, F32:$t_min, V3F32:$direction, F32:$t_max, PointerType:$payload, value:$paq);

  let summary = "Trace a ray";
  let description = [{
    Trace a ray in an acceleration structure and invoke intersection, any hit, closest hit and/or miss
    shaders as appropriate.

    - accelStruct: Address of the acceleration structure.

    - rayFlags: Per the DXR spec, controls traceRay behavior.

    - instanceInclusionMask: Per the DXR spec (but assumed to be already masked to 8 bits), used to include
      or reject geometry instances based on the instance mask in each instance.

    - rayContributionToHitGroupIndex: Per the DXR spec (but assumed to be already masked to 4 bits), offset
      to add to shader table addressing for hit group indexing.

    - multiplierForGeometryContributionToShaderIndex: Per the DXR spec (but assumed to be already masked to
      4 bits), stride to multiply GeometryContributionToHitGroupIndex by.

    - missShaderIndex: Per the DXR spec (but assumed to be already masked to 16 bits), miss shader index.

    - origin: Origin of the ray.

    - tMin: Minimum extent of the ray.

    - direction: Direction of the ray.

    - tMax: Maximum extent of the ray.

    - payload: User-defined payload, read and written by shaders called from TraceRayOp.

    - paq: The payload access qualifier as a constant int array. In the simplest case, the array has a
      single entry giving the payload size in bytes. TODO: Define and implement other cases.
  }];
}

// =========================================================================================================
def TraceRayOp : LgcRtOp<"trace.ray", [Memory<[(readwrite InaccessibleMem), (readwrite ArgMem)]>, WillReturn]> {
  let superclass = BaseTraceRayOp;
  let arguments = (ins superclass);
  let results = (outs);
}

// =========================================================================================================
def WorldRayDirectionOp : LgcRtOp<"world.ray.direction", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs V3F32:$result);

  let summary = "Return the world-space direction for the current ray";
  let description = [{
    Return a <3 x float> vector giving the world-space direction for the current ray.
  }];
}

// =========================================================================================================
def WorldRayOriginOp : LgcRtOp<"world.ray.origin", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs V3F32:$result);

  let summary = "Return the world-space origin for the current ray";
  let description = [{
    Return a <3 x float> vector giving the world-space origin for the current ray.
  }];
}

// =========================================================================================================
def WorldToObjectOp : LgcRtOp<"world.to.object", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs A4V3F32:$result);

  let summary = "Return the current world-to-object transformation matrix";
  let description = [{
    Return a [4 x <3 x float>] matrix (array-of-vectors) giving the world-to-object transformation
    matrix for the current intersection.
  }];
}

// =========================================================================================================
def TriangleVertexPositionsOp : LgcRtOp<"triangle.vertex.positions", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments =  (ins PointerType:$hitObject);
  let results = (outs A3V3F32:$result);

  let summary = "Return the object-space vertices of the triangle";
  let description = [{
    Return [3 x <3 x float>] object space vertices of the triangle at the current intersection.
  }];
}

// =========================================================================================================
def InstanceInclusionMaskOp : LgcRtOp<"instance.inclusion.mask", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments =  (ins PointerType:$hitObject);
  let results = (outs I32:$result);

  let summary = "Return the instance inclusion mask";
  let description = [{
    Return an i32 giving the instance inclusion mask for the ray being traced.
  }];
}

// =========================================================================================================
def HitObjectMakeNopOp : LgcRtOp<"hit.object.make.nop", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I126:$hitObject);
  let summary = "Returns Empty Hit Object";
  let description = [{
    Returns an Empty Hit Object.
  }];
}

// =========================================================================================================
def HitObjectIsMissOp : LgcRtOp<"hit.object.is.miss", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I1:$result);
  let summary = "Returns if hit object is a miss";
  let description = [{
    Returns a boolean indicating whether the hit object has encoded a miss.

    - hitObject: Pointer to HitObject.
  }];
}

// =========================================================================================================
def HitObjectIsHitOp : LgcRtOp<"hit.object.is.hit", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I1:$result);
  let summary = "Returns if hit object is a hit";
  let description = [{
    Returns a boolean indicating whether the hit object has encoded a hit.

    - hitObject: Pointer to HitObject.
  }];
}

// =========================================================================================================
def HitObjectIsEmptyOp : LgcRtOp<"hit.object.is.empty", [Memory<[(read ArgMem)]>, WillReturn]> {
   let arguments = (ins PointerType:$hitObject);
  let results = (outs I1:$result);
  let summary = "Returns if hit object is empty";
  let description = [{
    Returns a boolean indicating whether the hit object has encoded as empty.

    - hitObject: Pointer to HitObject.
  }];
}

// =========================================================================================================
def HitObjectGetPrimitiveIndexOp : LgcRtOp<"hit.object.get.primitive.index", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);
  let summary = "Returns the primitive index as encoded in the hit object";
  let description = [{
    Returns the primitive index as encoded in the hit object.

    - hitObject: Pointer to HitObject.
  }];
}

// =========================================================================================================
def HitObjectGetKindOp : LgcRtOp<"hit.object.get.kind", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);
  let summary = "Returns a encoded value in the hit object with front face or back face of a primitive";
  let description = [{
    0xFE if hit encoded in the hit object is with front facing primitive else is 0xFF if it is back facing
    primitive.

    - hitObject: Pointer to HitObject.
  }];
}

// =========================================================================================================
def HitObjectGetShaderTableIndexOp : LgcRtOp<"hit.object.get.shader.table.index", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject);
  let results = (outs I32:$result);
  let summary = "Returns the index for the record in shader binding table as encoded in hit object";
  let description = [{
    Returns the index for the record in shader binding table as encoded in hit object.

    - hitObject: Pointer to HitObject.
  }];
}

// =========================================================================================================
def HitObjectSetShaderTableIndexOp : LgcRtOp<"hit.object.set.shader.table.index", [Memory<[(read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject, I32:$sbtindex);
  let results = (outs I126:$result);
  let summary = "Returns a hit object with the given index for the record in the shader binding table";
  let description = [{
    Sets the index for the record in the shader binding table and returns it as a new hit object.

    - hitObject: Pointer to HitObject.

    - sbtindex: The new SBT index value to encode in the hit object.
  }];
}

// =========================================================================================================
def HitObjectExecuteShaderOp : LgcRtOp<"hit.object.execute.shader", [Memory<[(readwrite InaccessibleMem), (readwrite ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject, PointerType:$payload, value:$paq);
  let results = (outs);
  let summary = "Hit Object Execute Shader";
  let description = [{
    Executes the closest-hit or miss shader as encoded in the hit object.

    If the hit object encodes an empty hit object or was created from a ray query with no shader index set no function
    is called.

    - hitObject: Pointer to HitObject.

    - payload: User-defined payload, read and written by shaders called from TraceRayOp.

    - paq: The payload access qualifier as a constant int array. In the simplest case, the array has a
      single entry giving the payload size in bytes.
  }];
}

// =========================================================================================================
def ReorderThreadWithHitObjectOp : LgcRtOp<"reorder.thread.with.hit.object", [Memory<[(readwrite InaccessibleMem), (read ArgMem)]>, WillReturn]> {
  let arguments = (ins PointerType:$hitObject, I32:$hint, I32:$bits);
  let results = (outs);
  let summary = "Reorder Thread With Hit Object";
  let description = [{
    Reorder threads based on hit object supplemented by 'Hint' and 'Bits' if they are optionally provided values.
    Behavior is implementation-defined.

    - hitObject: Pointer to HitObject.

    - hint: Determines desired ordering of threads relative to others.

    - bits: Indicates number of least significant bits an implementation
            should take into account from <hint> in determining ordering.
  }];
}

// =========================================================================================================
def HitObjectTraceRayOp : LgcRtOp<"hit.object.trace.ray", [Memory<[(readwrite InaccessibleMem), (readwrite ArgMem)]>, WillReturn]> {
  let superclass = BaseTraceRayOp;
  let arguments = (ins superclass);
  let results = (outs I126:$result);
  let summary = "Trace Ray and store results in a HitObject";
  let description = [{
    Traces a ray and triggers execution on any-hit or intersection shaders and populates resulting hit or miss information and returns a hit object.
  }];
}

// =========================================================================================================
def GlobalHitObjectOp : LgcRtOp<"global.hit.object", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs (PointerType $address_space):$hitObject);

  let defaultBuilderHasExplicitResultType = true;

  let summary = "Get Global Hit Object";
  let description = [{
    Get the global hit object. The global hit object is used for all operations that do not explicitly specify a hit object.
    This is all functions that query raytracing state in intersection, anyHit, closestHit and miss shaders.
  }];
}
