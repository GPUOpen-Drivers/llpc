/*
 ***********************************************************************************************************************
 *
 *  Copyright (c) 2023-2024 Advanced Micro Devices, Inc. All Rights Reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 *
 **********************************************************************************************************************/

// lgc.rt dialect definition: ops for ray-tracing that are generated by language readers and lowered in the
// ray-tracing lowering passes.
//
// In addition to the ops defined here, this dialect defines certain properties of shaders:
//
// * A ray-tracing shader has its shader stage set using lgc::rt::setLgcRtShaderStage. You can use
//   lgc::rt::getLgcRtShaderStage to get the marked shader stage back. The client is responsible for
//   translating the enum value back as required.
//
// * A ray-tracing shader returns void, and takes 0, 1 or 2 pointer args (private address space) as appropriate:
//   - rayGen: 0 args
//   - intersection: 0 args
//   - anyHit: payload and optional hit attribute
//   - closestHit: payload and optional hit attribute
//   - miss: payload
//   - callable: callable data
//
// * A shader with a payload arg has a metadata item giving the PAQ (payload access qualifier); you set and
//   get that with setShaderPaq() and getShaderPaq() functions in LgcRtDialect.h. A PAQ is a constant array
//   of ints; currently the only supported form is a single-entry array where the value is the size in bytes
//   of the payload. This is the same form of PAQ that is passed as an arg to TraceRayOp.
//   A pipeline-wide upper bound on the payload size in bytes can be accessed via getMaxPayloadSize() and
//   getMaxPayloadSize().
//
// * A shader with a hit attribute arg has a metadata item giving the hit attribute size in bytes,
//   which is guaranteed to be not larger than the pipeline-wide max hit attribute size.
//   The per-shader hit attribute size is accessed using setShaderHitAttributeSize() and
//   getHitShaderAttributeSize() in LgcRtDialect.h.
//   The pipeline-wide maximum sizes can be accessed accessed using getMaxHitAttributeSize()
//   and setMaxHitAttributeSize().
//
// * A callable shader has a metadata item giving the callable data size in bytes; that is set and got using
//   setShaderArgSize() and getShaderArgSize() in LgcRtDialect.h.

include "llvm-dialects/Dialect/Dialect.td"

def LgcRtDialect : Dialect {
  let name = "lgc.rt";
  let cppNamespace = "lgc::rt";
}

def V3F32 : TgConstant<(FixedVectorType F32, 3)>, Type;
def V3I32 : TgConstant<(FixedVectorType I32, 3)>, Type;
def A4V3F32 : TgConstant<(ArrayType V3F32, 4)>, Type;
def A3V3F32 : TgConstant<(ArrayType V3F32, 3)>, Type;

def GlobalPointer : TgConstant<(PointerType 1)>, Type;
def PrivatePointer : TgConstant<(PointerType 5)>, Type;

class LgcRtOp<string mnemonic_, list<Trait> traits_ = []>
    : Op<LgcRtDialect, mnemonic_, traits_ # [NoUnwind]>;

// =========================================================================================================
def AcceptHitAndEndSearchOp : LgcRtOp<"accept.hit.and.end.search", [Memory<[(write InaccessibleMem)]>, NoReturn]> {
  let arguments = (ins);
  let results = (outs);

  let summary = "Accept a hit in an anyHit shader";
  let description = [{
    Used in an anyHit shader to accept the current hit and stop searching for more hits. The intersection
    shader that caused this anyHit shader to run (if any) will exit, and execution will pass to the
    closestHit shader if any.
  }];
}

// =========================================================================================================
def CallCallableShaderOp : LgcRtOp<"call.callable.shader", [Memory<[(readwrite InaccessibleMem), (readwrite ArgMem)]>, WillReturn]> {
  let arguments = (ins I32:$shader_index, PointerType:$param, AttrI32:$param_data_size_bytes);
  let results = (outs);

  let summary = "Call a ray-tracing callable shader";
  let description = [{
    Call the ray-tracing callable shader at the specified index in the callable shader table,
    passing the parameter in and out. $param_data_size_bytes refers to the size of the data
    pointed to by $param, given in bytes.
  }];
}

// =========================================================================================================
def DispatchRaysDimensionsOp : LgcRtOp<"dispatch.rays.dimensions", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3I32:$result);

  let summary = "Return the dispatchRays dimensions";
  let description = [{
    Return a <3 x i32> vector giving the X,Y,Z dimensions of the dispatchRays.
  }];
}

// =========================================================================================================
def DispatchRaysIndexOp : LgcRtOp<"dispatch.rays.index", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3I32:$result);

  let summary = "Return the dispatchRays index";
  let description = [{
    Return a <3 x i32> vector giving the X,Y,Z index of the current ray in the dispatchRays.
  }];
}

// =========================================================================================================
def GeometryIndexOp : LgcRtOp<"geometry.index", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the geometry index";
  let description = [{
    Return an i32 giving the geometry index.
  }];
}

// =========================================================================================================
def HitKindOp : LgcRtOp<"hit.kind", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the hit kind";
  let description = [{
    Return an i32 giving the hit kind passed in to ReportHit. For a fixed-function triangle intersection,
    it is 254 for front-facing or 255 for back-facing.
  }];
}

// =========================================================================================================
def IgnoreHitOp : LgcRtOp<"ignore.hit", [Memory<[(write InaccessibleMem)]>, NoReturn]> {
  let arguments = (ins);
  let results = (outs);

  let summary = "Ignore a hit in an anyHit shader";
  let description = [{
    Used in an anyHit shader to reject the hit and end the shader. The ReportHitOp in the intersection
    shader that caused this anyHit shader to run will return false.
  }];
}

// =========================================================================================================
def InstanceIdOp : LgcRtOp<"instance.id", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the instance ID";
  let description = [{
    Return an i32 giving the user-provided instance ID on the bottom-level acceleration structure instance
    within the top-level structure.
  }];
}

// =========================================================================================================
def InstanceIndexOp : LgcRtOp<"instance.index", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the instance index";
  let description = [{
    Return an i32 giving the autogenerated index of the current instance in the top-level structure.
  }];
}

// =========================================================================================================
def ObjectRayDirectionOp : LgcRtOp<"object.ray.direction", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3F32:$result);

  let summary = "Return the object-space direction";
  let description = [{
    Return a <3 x float> vector giving the object-space direction for the current ray.
  }];
}

// =========================================================================================================
def ObjectRayOriginOp : LgcRtOp<"object.ray.origin", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3F32:$result);

  let summary = "Return the object-space origin";
  let description = [{
    Return a <3 x float> vector giving the object-space origin for the current ray.
  }];
}

// =========================================================================================================
def ObjectToWorldOp : LgcRtOp<"object.to.world", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs A4V3F32:$result);

  let summary = "Return the current object-to-world transformation matrix";
  let description = [{
    Return a [4 x <3 x float>] matrix (array-of-vectors) giving the object-to-world transformation
    matrix for the current intersection.
  }];
}

// =========================================================================================================
def PrimitiveIndexOp : LgcRtOp<"primitive.index", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the primitive index";
  let description = [{
    Return an i32 giving the primitive index.
  }];
}

// =========================================================================================================
def RayFlagsOp : LgcRtOp<"ray.flags", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the current ray flags";
  let description = [{
    Return an i32 giving the current ray flags.
  }];
}

// =========================================================================================================
def RayTcurrentOp : LgcRtOp<"ray.tcurrent", [Memory<[(read)]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs F32:$result);

  let summary = "Return the current parametric ending point for the ray";
  let description = [{
    Return a float giving the current parametric ending point for the ray.
  }];
}

// =========================================================================================================
def RayTminOp : LgcRtOp<"ray.tmin", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs F32:$result);

  let summary = "Return the parametric starting point for the ray";
  let description = [{
    Return a float giving the parametric starting point for the ray.
  }];
}

// =========================================================================================================
def ReportHitOp : LgcRtOp<"report.hit", [Memory<[(write InaccessibleMem), (read ArgMem)]>]> {
  let arguments = (ins F32:$thit, I32:$hit_kind, PointerType:$attributes, AttrI32:$size);
  let results = (outs I1:$result);

  let summary = "Report a hit in an intersection shader";
  let description = [{
    Report a hit in an intersection shader, returning true if the hit was accepted. A hit is rejected
    if thit is outside the current ray interval or if the anyHit shader calls IgnoreHitOp.

    - thit: Parametric distance of the intersection.

    - hit_kind: User-specified hit kind in the range 0-127, visible to anyHit and closestHit shaders using
      HitKindOp.

    - attributes: User-defined intersection attributes.

    - size: Size of the data pointed to by attributes (in bytes)
  }];
}

// =========================================================================================================
def ShaderIndexOp : LgcRtOp<"shader.index", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs I32:$result);

  let summary = "Return the current shader index";
  let description = [{
    Return the current shader index.

    The shader index is used to index into the shader binding table, i.e. the table which backs the
    Vulkan shader record buffers or the DX12 local root signatures.
  }];
}

// =========================================================================================================
def ShaderRecordBufferOp : LgcRtOp<"shader.record.buffer", [Memory<[]>, WillReturn]> {
  let arguments = (ins I32:$shader_index);
  let results = (outs GlobalPointer:$ptr);

  let summary = "Return the pointer to shader record buffer";
  let description = [{
    Return the pointer to shader record buffer.

    - shader_index: The value used to index into the shader binding table.
  }];
}

// =========================================================================================================
def BaseTraceRayOp : OpClass<LgcRtDialect> {
  let arguments = (ins I64:$accel_struct, I32:$ray_flags, I32:$instance_inclusion_mask,
      I32:$ray_contribution_to_hit_group_index, I32:$multiplier_for_geometry_contribution, I32:$miss_shader_index,
      V3F32:$origin, F32:$t_min, V3F32:$direction, F32:$t_max, PointerType:$payload, value:$paq);

  let summary = "Trace a ray";
  let description = [{
    Trace a ray in an acceleration structure and invoke intersection, any hit, closest hit and/or miss
    shaders as appropriate.

    - accelStruct: Address of the acceleration structure.

    - rayFlags: Per the DXR spec, controls traceRay behavior.

    - instanceInclusionMask: Per the DXR spec (but assumed to be already masked to 8 bits), used to include
      or reject geometry instances based on the instance mask in each instance.

    - rayContributionToHitGroupIndex: Per the DXR spec (but assumed to be already masked to 4 bits), offset
      to add to shader table addressing for hit group indexing.

    - multiplierForGeometryContributionToShaderIndex: Per the DXR spec (but assumed to be already masked to
      4 bits), stride to multiply GeometryContributionToHitGroupIndex by.

    - missShaderIndex: Per the DXR spec (but assumed to be already masked to 16 bits), miss shader index.

    - origin: Origin of the ray.

    - tMin: Minimum extent of the ray.

    - direction: Direction of the ray.

    - tMax: Maximum extent of the ray.

    - payload: User-defined payload, read and written by shaders called from TraceRayOp.

    - paq: The payload access qualifier as a constant int array. In the simplest case, the array has a
      single entry giving the payload size in bytes. TODO: Define and implement other cases.
  }];
}

// =========================================================================================================
def TraceRayOp : LgcRtOp<"trace.ray", [Memory<[(readwrite InaccessibleMem), (readwrite ArgMem)]>, WillReturn]> {
  let superclass = BaseTraceRayOp;
  let arguments = (ins superclass);
  let results = (outs);
}

// =========================================================================================================
def WorldRayDirectionOp : LgcRtOp<"world.ray.direction", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3F32:$result);

  let summary = "Return the world-space direction for the current ray";
  let description = [{
    Return a <3 x float> vector giving the world-space direction for the current ray.
  }];
}

// =========================================================================================================
def WorldRayOriginOp : LgcRtOp<"world.ray.origin", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs V3F32:$result);

  let summary = "Return the world-space origin for the current ray";
  let description = [{
    Return a <3 x float> vector giving the world-space origin for the current ray.
  }];
}

// =========================================================================================================
def WorldToObjectOp : LgcRtOp<"world.to.object", [Memory<[]>, WillReturn]> {
  let arguments = (ins);
  let results = (outs A4V3F32:$result);

  let summary = "Return the current world-to-object transformation matrix";
  let description = [{
    Return a [4 x <3 x float>] matrix (array-of-vectors) giving the world-to-object transformation
    matrix for the current intersection.
  }];
}

// =========================================================================================================
def TriangleVertexPositionsOp : LgcRtOp<"triangle.vertex.positions", [Memory<[]>, WillReturn]> {
  let arguments =  (ins);
  let results = (outs A3V3F32:$result);

  let summary = "Return the object-space vertices of the triangle";
  let description = [{
    Return [3 x <3 x float>] object space vertices of the triangle at the current intersection.
  }];
}

// =========================================================================================================
def InstanceInclusionMaskOp : LgcRtOp<"instance.inclusion.mask", [Memory<[]>, WillReturn]> {
  let arguments =  (ins);
  let results = (outs I32:$result);

  let summary = "Return the instance inclusion mask";
  let description = [{
    Return an i32 giving the instance inclusion mask for the ray being traced.
  }];
}

