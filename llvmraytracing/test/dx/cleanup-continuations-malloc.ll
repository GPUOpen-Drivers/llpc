; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt --verify-each -passes='lower-await,lint,coro-early,dxil-coro-split,coro-cleanup,lint,cleanup-continuations,lint' -S %s --lint-abort-on-error | FileCheck %s

target datalayout = "e-m:e-p:64:32-p20:32:32-p21:32:32-p32:32:32-i1:32-i8:8-i16:16-i32:32-i64:32-f16:16-f32:32-f64:32-v8:8-v16:16-v32:32-v48:32-v64:32-v80:32-v96:32-v112:32-v128:32-v144:32-v160:32-v176:32-v192:32-v208:32-v224:32-v240:32-v256:32-n8:16:32"

declare void @lgc.cps.await__void(...)
declare ptr @async_fun(i64, i32)
declare void @lgc.cps.jump(...)
declare void @lgc.cps.complete()

define <4 x i32> @simple_await(i32 %dummyRet, <4 x i32> %arg) !continuation.registercount !1 {
; CHECK-LABEL: define void @simple_await(
; CHECK-SAME: i32 [[CSPINIT:%.*]], i32 [[DUMMYRET:%.*]], <4 x i32> [[ARG:%.*]]) !continuation.registercount [[META1:![0-9]+]] !continuation [[META2:![0-9]+]] !continuation.stacksize [[META3:![0-9]+]] !continuation.state [[META3]] {
; CHECK-NEXT:  AllocaSpillBB:
; CHECK-NEXT:    [[CSP:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[CSPINIT]], ptr [[CSP]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[CSP]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 20
; CHECK-NEXT:    store i32 [[TMP8]], ptr [[CSP]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i32 [[TMP7]] to ptr addrspace(21)
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(21) [[TMP2]], i32 0
; CHECK-NEXT:    store <4 x i32> [[ARG]], ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = add i32 [[TMP7]], 16
; CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i32 [[TMP4]] to ptr addrspace(21)
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(21) [[TMP5]], i32 0
; CHECK-NEXT:    store i32 [[DUMMYRET]], ptr addrspace(21) [[TMP6]], align 4
; CHECK-NEXT:    [[CALLEE:%.*]] = ptrtoint ptr @async_fun to i32
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i32 [[CALLEE]] to ptr
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 (...) @lgc.cps.as.continuation.reference(ptr @simple_await.resume.0)
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[CSP]], align 4
; CHECK-NEXT:    call void (...) @lgc.cps.jump(i32 [[CALLEE]], i32 -1, i32 [[TMP9]], i32 [[TMP1]]), !continuation.registercount [[META1]], !continuation.returnedRegistercount [[META1]]
; CHECK-NEXT:    unreachable
;
  %callee = ptrtoint ptr @async_fun to i32
  call void (...) @lgc.cps.await__void(i32 %callee, i32 3), !continuation.registercount !1, !continuation.returnedRegistercount !1
  call void (...) @lgc.cps.jump(i32 %dummyRet, i32 -1, i32 poison, i32 poison, <4 x i32> %arg), !continuation.registercount !1
  unreachable
}

define void @simple_await_entry(i32 %dummyRet, <4 x i32> %arg, <4 x i32> addrspace(1)* %mem) !continuation.entry !0 !continuation.registercount !1 {
; CHECK-LABEL: define void @simple_await_entry(
; CHECK-SAME: i32 [[CSPINIT:%.*]], i32 [[DUMMYRET:%.*]], <4 x i32> [[ARG:%.*]], ptr addrspace(1) [[MEM:%.*]]) !continuation.registercount [[META1]] !continuation.entry [[META4:![0-9]+]] !continuation [[META5:![0-9]+]] !continuation.stacksize [[META6:![0-9]+]] !continuation.state [[META6]] {
; CHECK-NEXT:  AllocaSpillBB:
; CHECK-NEXT:    [[CSP:%.*]] = alloca i32, align 4
; CHECK-NEXT:    store i32 [[CSPINIT]], ptr [[CSP]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, ptr [[CSP]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = add i32 [[TMP7]], 24
; CHECK-NEXT:    store i32 [[TMP8]], ptr [[CSP]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = add i32 [[TMP7]], 16
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr i32 [[TMP2]] to ptr addrspace(21)
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr i8, ptr addrspace(21) [[TMP3]], i32 0
; CHECK-NEXT:    store ptr addrspace(1) [[MEM]], ptr addrspace(21) [[TMP4]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i32 [[TMP7]] to ptr addrspace(21)
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(21) [[TMP5]], i32 0
; CHECK-NEXT:    store <4 x i32> [[ARG]], ptr addrspace(21) [[TMP6]], align 4
; CHECK-NEXT:    [[CALLEE:%.*]] = ptrtoint ptr @async_fun to i32
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i32 [[CALLEE]] to ptr
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 (...) @lgc.cps.as.continuation.reference(ptr @simple_await_entry.resume.0)
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr [[CSP]], align 4
; CHECK-NEXT:    call void (...) @lgc.cps.jump(i32 [[CALLEE]], i32 -1, i32 [[TMP9]], i32 [[TMP1]]), !continuation.registercount [[META1]], !continuation.returnedRegistercount [[META1]]
; CHECK-NEXT:    unreachable
;
  %callee = ptrtoint ptr @async_fun to i32
  call void (...) @lgc.cps.await__void(i32 %callee, i32 3), !continuation.registercount !1, !continuation.returnedRegistercount !1
  store <4 x i32> %arg, <4 x i32> addrspace(1)* %mem
  call void @lgc.cps.complete(), !continuation.registercount !1
  unreachable
}

!continuation.stackAddrspace = !{!2}

!0 = !{}
!1 = !{i32 0}
!2 = !{i32 21}
