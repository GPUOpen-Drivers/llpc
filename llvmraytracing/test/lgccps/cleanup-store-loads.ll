; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --include-generated-funcs --version 3
; RUN: opt --verify-each -S -o - -passes='cgscc(inline),cleanup-continuations' %s | FileCheck --check-prefixes=CHECK %s

declare !lgc.cps !0 void @callee({}, i32, float)

declare i64 @getVal64()
declare void @useVal64(i64)
declare i32 @getVal32()
declare void @useVal32(i32)
declare void @useValF32(float)
declare i8 @getVal8()
declare void @useVal8(i8)

; Calls getVal32() to obtain a value, and writes it
; to the given offset in data.
define void @storeToOffsetI32(ptr %data, i32 %offset) #4 {
  %val = call i32 @getVal32()
  %addr = getelementptr i8, ptr %data, i32 %offset
  store i32 %val, ptr %addr, align 2
  ret void
}

; I8 version store
define void @storeToOffsetI8(ptr %data, i32 %offset) #4 {
  %val = call i8 @getVal8()
  %addr = getelementptr i8, ptr %data, i32 %offset
  store i8 %val, ptr %addr
  ret void
}

; I64 version store
define void @storeToOffsetI64(ptr %data, i32 %offset) #4 {
  %val = call i64 @getVal64()
  %addr = getelementptr i8, ptr %data, i32 %offset
  store i64 %val, ptr %addr
  ret void
}

; Loads the value in data at the given offset, and
; feeds it into useVal32().
define void @loadAtOffsetI32(ptr %data, i32 %offset) #4 {
  %addr = getelementptr i8, ptr %data, i32 %offset
  %val.reload = load i32, ptr %addr
  call void @useVal32(i32 %val.reload)
  ret void
}

; I64 version load
define void @loadAtOffsetI64(ptr %data, i32 %offset) #4 {
  %addr = getelementptr i8, ptr %data, i32 %offset
  %val.reload = load i32, ptr %addr
  call void @useVal32(i32 %val.reload)
  ret void
}

; F32 version load
define void @loadAtOffsetF32(ptr %data, i32 %offset) #4 {
  %addr = getelementptr i8, ptr %data, i32 %offset
  %val.reload = load float, ptr %addr
  call void @useValF32(float %val.reload)
  ret void
}

%test.Frame = type { i32, float, [100 x i32] }

define { ptr, ptr } @test({} %state, i32 %rcr, float %arg, ptr %0) !lgc.cps !0 !continuation !1 {
entry:
  %1 = call ptr @continuation.malloc(i32 408)
  store ptr %1, ptr %0, align 8

  %arg.spill.addr = getelementptr inbounds %test.Frame, ptr %1, i32 0, i32 1
  store float %arg, ptr %arg.spill.addr, align 4
  %rcr.spill.addr = getelementptr inbounds %test.Frame, ptr %1, i32 0, i32 0
  store i32 %rcr, ptr %rcr.spill.addr, align 4

  %t0 = fadd float %arg, 1.000000e+00
  %cr = call i32 @lgc.cps.as.continuation.reference(ptr @callee)
  %cond = fcmp olt float %t0, 1.000000e+00
  %data = getelementptr inbounds %test.Frame, ptr %1, i32 0, i32 2

  ; Matching load/store pair at offset 0 in data. range: [0, 4)
  call void @storeToOffsetI32(ptr %data, i32 0)

  ; Double store, no forwarding (even though we could, the second dominates the load)
  call void @storeToOffsetI32(ptr %data, i32 4)
  call void @storeToOffsetI32(ptr %data, i32 4)

  ; Store with conflicting store at the start point
  call void @storeToOffsetI32(ptr %data, i32 10)
  call void @storeToOffsetI32(ptr %data, i32 12)

  ; Store with conflicting store at the end point
  call void @storeToOffsetI32(ptr %data, i32 16)
  call void @storeToOffsetI32(ptr %data, i32 18)

  ; Store with conflicting store strictly inside its range
  call void @storeToOffsetI32(ptr %data, i32 24)
  call void @storeToOffsetI8(ptr %data, i32 25)

  ; Load from part of the store range
  call void @storeToOffsetI64(ptr %data, i32 28)

  ; Type mismatch
  call void @storeToOffsetI32(ptr %data, i32 36)

  ; Store does not dominate load
  call void @loadAtOffsetI32(ptr %data, i32 40)

  ; Check tightly packed loads/stores can be optimized correctly
  call void @storeToOffsetI32(ptr %data, i32 44)
  call void @storeToOffsetI32(ptr %data, i32 48)
  br i1 %cond, label %bb1, label %bb2

bb1:                                              ; preds = %entry
  %2 = inttoptr i32 %cr to ptr
  %3 = call ptr %2(i32 %cr, i32 2, float %arg)
  %4 = insertvalue { ptr, ptr } undef, ptr @test.resume.0, 0
  %5 = insertvalue { ptr, ptr } %4, ptr %3, 1
  ret { ptr, ptr } %5

bb2:                                              ; preds = %entry
  %t0.bb2 = phi float [ %t0, %entry ]
  %arg.reload.addr = getelementptr inbounds %test.Frame, ptr %1, i32 0, i32 1
  %arg.reload = load float, ptr %arg.reload.addr, align 4
  %rcr.reload.addr = getelementptr inbounds %test.Frame, ptr %1, i32 0, i32 0
  %rcr.reload = load i32, ptr %rcr.reload.addr, align 4
  %returnvalue = fmul float %t0.bb2, %arg.reload

  ; Perfect eliminated case
  call void @loadAtOffsetI32(ptr %data, i32 0)

  ; Double store, no forwarding (even though we could, the second dominates the load)
  call void @loadAtOffsetI32(ptr %data, i32 4)

  ; Store with conflicting store at the start point
  call void @loadAtOffsetI32(ptr %data, i32 12)

  ; Store with conflicting store at the end point
  call void @loadAtOffsetI32(ptr %data, i32 16)

  ; Store with conflicting store strictly inside its range
  call void @loadAtOffsetI32(ptr %data, i32 24)

  ; Load from part of the store range
  call void @loadAtOffsetI32(ptr %data, i32 32)

  ; Type mismatch
  call void @loadAtOffsetF32(ptr %data, i32 36)

  ; Store does not dominate load
  call void @storeToOffsetI32(ptr %data, i32 40)

  ; Check tightly packed loads/stores can be optimized correctly
  call void @loadAtOffsetI32(ptr %data, i32 44)
  call void @loadAtOffsetI32(ptr %data, i32 48)

  ; Multiple loads can be optimized away
  call void @loadAtOffsetI32(ptr %data, i32 48)

  call void (...) @lgc.cps.jump(i32 %rcr.reload, i32 2, {} poison, i32 poison, float %returnvalue)
  unreachable
}

define internal { ptr, ptr } @test.resume.0(ptr noalias noundef nonnull align 4 dereferenceable(8) %0, i1 %1) !lgc.cps !0 !continuation !1 {
entryresume.0:
  %2 = load ptr, ptr %0, align 8
  %3 = call float @lgc.ilcps.getReturnValue__f32()
  %arg.reload.addr = getelementptr inbounds %test.Frame, ptr %2, i32 0, i32 1
  %arg.reload = load float, ptr %arg.reload.addr, align 4
  %rcr.reload.addr = getelementptr inbounds %test.Frame, ptr %2, i32 0, i32 0
  %rcr.reload = load i32, ptr %rcr.reload.addr, align 4
  %returnvalue = fmul float %3, %arg.reload
  call void (...) @lgc.cps.jump(i32 %rcr.reload, i32 2, {} poison, i32 poison, float %returnvalue)
  unreachable
}

; Function Attrs: memory(none)
declare i32 @lgc.cps.as.continuation.reference(...) #0

declare float @lgc.cps.await__f32(...)

declare void @lgc.cps.jump(...)

declare !continuation !1 { ptr, ptr } @continuation.prototype.test(ptr, i1)

declare ptr @continuation.malloc(i32)

declare void @continuation.free(ptr)

; Function Attrs: nounwind
declare token @llvm.coro.id.retcon(i32, i32, ptr, ptr, ptr, ptr) #1

; Function Attrs: nounwind
declare ptr @llvm.coro.begin(token, ptr writeonly) #1

; Function Attrs: nounwind
declare i1 @llvm.coro.suspend.retcon.i1(...) #1

; Function Attrs: nounwind willreturn
declare float @lgc.ilcps.getReturnValue__f32() #2

; Function Attrs: noreturn
declare void @continuation.return(...) #3

attributes #0 = { memory(none) }
attributes #1 = { nounwind }
attributes #2 = { nounwind willreturn }
attributes #3 = { noreturn }
attributes #4 = { alwaysinline }

!0 = !{i32 1}
!1 = !{ptr @test}
; CHECK-LABEL: define void @storeToOffsetI32(
; CHECK-SAME: ptr [[DATA:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[VAL:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i8, ptr [[DATA]], i32 [[OFFSET]]
; CHECK-NEXT:    store i32 [[VAL]], ptr [[ADDR]], align 2
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define void @storeToOffsetI8(
; CHECK-SAME: ptr [[DATA:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = call i8 @getVal8()
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i8, ptr [[DATA]], i32 [[OFFSET]]
; CHECK-NEXT:    store i8 [[VAL]], ptr [[ADDR]], align 1
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define void @storeToOffsetI64(
; CHECK-SAME: ptr [[DATA:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[VAL:%.*]] = call i64 @getVal64()
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i8, ptr [[DATA]], i32 [[OFFSET]]
; CHECK-NEXT:    store i64 [[VAL]], ptr [[ADDR]], align 4
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define void @loadAtOffsetI32(
; CHECK-SAME: ptr [[DATA:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i8, ptr [[DATA]], i32 [[OFFSET]]
; CHECK-NEXT:    [[VAL_RELOAD:%.*]] = load i32, ptr [[ADDR]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define void @loadAtOffsetI64(
; CHECK-SAME: ptr [[DATA:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i8, ptr [[DATA]], i32 [[OFFSET]]
; CHECK-NEXT:    [[VAL_RELOAD:%.*]] = load i32, ptr [[ADDR]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define void @loadAtOffsetF32(
; CHECK-SAME: ptr [[DATA:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i8, ptr [[DATA]], i32 [[OFFSET]]
; CHECK-NEXT:    [[VAL_RELOAD:%.*]] = load float, ptr [[ADDR]], align 4
; CHECK-NEXT:    call void @useValF32(float [[VAL_RELOAD]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define void @test(
; CHECK-SAME: {} [[STATE:%.*]], i32 [[RCR:%.*]], float [[ARG:%.*]]) !lgc.cps [[META0:![0-9]+]] !continuation [[META1:![0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CONT_STATE_STACK_SEGMENT:%.*]] = call ptr addrspace(32) @lgc.cps.alloc(i32 408)
; CHECK-NEXT:    [[ARG_SPILL_ADDR:%.*]] = getelementptr inbounds [[TEST_FRAME:%.*]], ptr addrspace(32) [[CONT_STATE_STACK_SEGMENT]], i32 0, i32 1
; CHECK-NEXT:    store float [[ARG]], ptr addrspace(32) [[ARG_SPILL_ADDR]], align 4
; CHECK-NEXT:    [[RCR_SPILL_ADDR:%.*]] = getelementptr inbounds [[TEST_FRAME]], ptr addrspace(32) [[CONT_STATE_STACK_SEGMENT]], i32 0, i32 0
; CHECK-NEXT:    store i32 [[RCR]], ptr addrspace(32) [[RCR_SPILL_ADDR]], align 4
; CHECK-NEXT:    [[T0:%.*]] = fadd float [[ARG]], 1.000000e+00
; CHECK-NEXT:    [[CR:%.*]] = call i32 @lgc.cps.as.continuation.reference(ptr @callee)
; CHECK-NEXT:    [[COND:%.*]] = fcmp olt float [[T0]], 1.000000e+00
; CHECK-NEXT:    [[DATA:%.*]] = getelementptr inbounds [[TEST_FRAME]], ptr addrspace(32) [[CONT_STATE_STACK_SEGMENT]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_I:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    store i32 [[VAL_I]], ptr addrspace(32) [[DATA]], align 2
; CHECK-NEXT:    [[VAL_I1:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 4
; CHECK-NEXT:    store i32 [[VAL_I1]], ptr addrspace(32) [[ADDR_I]], align 2
; CHECK-NEXT:    [[VAL_I2:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I3:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 4
; CHECK-NEXT:    store i32 [[VAL_I2]], ptr addrspace(32) [[ADDR_I3]], align 2
; CHECK-NEXT:    [[VAL_I4:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I5:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 10
; CHECK-NEXT:    store i32 [[VAL_I4]], ptr addrspace(32) [[ADDR_I5]], align 2
; CHECK-NEXT:    [[VAL_I6:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I7:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 12
; CHECK-NEXT:    store i32 [[VAL_I6]], ptr addrspace(32) [[ADDR_I7]], align 2
; CHECK-NEXT:    [[VAL_I8:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I9:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 16
; CHECK-NEXT:    store i32 [[VAL_I8]], ptr addrspace(32) [[ADDR_I9]], align 2
; CHECK-NEXT:    [[VAL_I10:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I11:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 18
; CHECK-NEXT:    store i32 [[VAL_I10]], ptr addrspace(32) [[ADDR_I11]], align 2
; CHECK-NEXT:    [[VAL_I12:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I13:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 24
; CHECK-NEXT:    store i32 [[VAL_I12]], ptr addrspace(32) [[ADDR_I13]], align 2
; CHECK-NEXT:    [[VAL_I14:%.*]] = call i8 @getVal8()
; CHECK-NEXT:    [[ADDR_I15:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 25
; CHECK-NEXT:    store i8 [[VAL_I14]], ptr addrspace(32) [[ADDR_I15]], align 1
; CHECK-NEXT:    [[VAL_I16:%.*]] = call i64 @getVal64()
; CHECK-NEXT:    [[ADDR_I17:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 28
; CHECK-NEXT:    store i64 [[VAL_I16]], ptr addrspace(32) [[ADDR_I17]], align 4
; CHECK-NEXT:    [[VAL_I18:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I19:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 36
; CHECK-NEXT:    store i32 [[VAL_I18]], ptr addrspace(32) [[ADDR_I19]], align 2
; CHECK-NEXT:    [[ADDR_I20:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 40
; CHECK-NEXT:    [[VAL_RELOAD_I:%.*]] = load i32, ptr addrspace(32) [[ADDR_I20]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD_I]])
; CHECK-NEXT:    [[VAL_I21:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I22:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 44
; CHECK-NEXT:    store i32 [[VAL_I21]], ptr addrspace(32) [[ADDR_I22]], align 2
; CHECK-NEXT:    [[VAL_I23:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I24:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 48
; CHECK-NEXT:    store i32 [[VAL_I23]], ptr addrspace(32) [[ADDR_I24]], align 2
; CHECK-NEXT:    br i1 [[COND]], label [[BB1:%.*]], label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i32 [[CR]] to ptr
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 (...) @lgc.cps.as.continuation.reference__i32(ptr @test.resume.0)
; CHECK-NEXT:    call void (...) @lgc.cps.jump(i32 [[CR]], i32 2, {} poison, i32 [[TMP1]], float [[ARG]])
; CHECK-NEXT:    unreachable
; CHECK:       bb2:
; CHECK-NEXT:    [[T0_BB2:%.*]] = phi float [ [[T0]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[RETURNVALUE:%.*]] = fmul float [[T0_BB2]], [[ARG]]
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_I]])
; CHECK-NEXT:    [[ADDR_I26:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 4
; CHECK-NEXT:    [[VAL_RELOAD_I27:%.*]] = load i32, ptr addrspace(32) [[ADDR_I26]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD_I27]])
; CHECK-NEXT:    [[ADDR_I28:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 12
; CHECK-NEXT:    [[VAL_RELOAD_I29:%.*]] = load i32, ptr addrspace(32) [[ADDR_I28]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD_I29]])
; CHECK-NEXT:    [[ADDR_I30:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 16
; CHECK-NEXT:    [[VAL_RELOAD_I31:%.*]] = load i32, ptr addrspace(32) [[ADDR_I30]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD_I31]])
; CHECK-NEXT:    [[ADDR_I32:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 24
; CHECK-NEXT:    [[VAL_RELOAD_I33:%.*]] = load i32, ptr addrspace(32) [[ADDR_I32]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD_I33]])
; CHECK-NEXT:    [[ADDR_I34:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 32
; CHECK-NEXT:    [[VAL_RELOAD_I35:%.*]] = load i32, ptr addrspace(32) [[ADDR_I34]], align 4
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_RELOAD_I35]])
; CHECK-NEXT:    [[ADDR_I36:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 36
; CHECK-NEXT:    [[VAL_RELOAD_I37:%.*]] = load float, ptr addrspace(32) [[ADDR_I36]], align 4
; CHECK-NEXT:    call void @useValF32(float [[VAL_RELOAD_I37]])
; CHECK-NEXT:    [[VAL_I38:%.*]] = call i32 @getVal32()
; CHECK-NEXT:    [[ADDR_I39:%.*]] = getelementptr i8, ptr addrspace(32) [[DATA]], i32 40
; CHECK-NEXT:    store i32 [[VAL_I38]], ptr addrspace(32) [[ADDR_I39]], align 2
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_I21]])
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_I23]])
; CHECK-NEXT:    call void @useVal32(i32 [[VAL_I23]])
; CHECK-NEXT:    call void @lgc.cps.free(i32 408)
; CHECK-NEXT:    call void (...) @lgc.cps.jump(i32 [[RCR]], i32 2, {} poison, i32 poison, float [[RETURNVALUE]])
; CHECK-NEXT:    unreachable
;
;
; CHECK-LABEL: define dso_local void @test.resume.0(
; CHECK-SAME: {} [[TMP0:%.*]], i32 [[TMP1:%.*]], i32 [[TMP2:%.*]], float [[TMP3:%.*]]) !lgc.cps [[META0]] !continuation [[META1]] {
; CHECK-NEXT:  entryresume.0:
; CHECK-NEXT:    [[TMP4:%.*]] = call ptr addrspace(32) @lgc.cps.peek(i32 408)
; CHECK-NEXT:    [[ARG_RELOAD_ADDR:%.*]] = getelementptr inbounds [[TEST_FRAME:%.*]], ptr addrspace(32) [[TMP4]], i32 0, i32 1
; CHECK-NEXT:    [[ARG_RELOAD:%.*]] = load float, ptr addrspace(32) [[ARG_RELOAD_ADDR]], align 4
; CHECK-NEXT:    [[RCR_RELOAD_ADDR:%.*]] = getelementptr inbounds [[TEST_FRAME]], ptr addrspace(32) [[TMP4]], i32 0, i32 0
; CHECK-NEXT:    [[RCR_RELOAD:%.*]] = load i32, ptr addrspace(32) [[RCR_RELOAD_ADDR]], align 4
; CHECK-NEXT:    [[RETURNVALUE:%.*]] = fmul float [[TMP3]], [[ARG_RELOAD]]
; CHECK-NEXT:    call void @lgc.cps.free(i32 408)
; CHECK-NEXT:    call void (...) @lgc.cps.jump(i32 [[RCR_RELOAD]], i32 2, {} poison, i32 poison, float [[RETURNVALUE]])
; CHECK-NEXT:    unreachable
;
