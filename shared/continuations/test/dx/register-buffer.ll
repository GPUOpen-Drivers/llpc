; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt --verify-each -passes='register-buffer,lint,instsimplify' -S %s 2>%t.stderr | FileCheck %s
; RUN: count 0 < %t.stderr

target datalayout = "e-m:e-p:64:32-p20:32:32-p21:32:32-i1:32-i8:8-i16:32-i32:32-i64:32-f16:32-f32:32-f64:32-v16:32-v32:32-v48:32-v64:32-v80:32-v96:32-v112:32-v128:32-v144:32-v160:32-v176:32-v192:32-v208:32-v224:32-v240:32-v256:32-n8:16:32"

; CHECK: @GLOBAL = external addrspace(20) global [15 x i32]
@GLOBAL = external global [20 x i32], !registerbuffer !1
!1 = !{ i32 15, i32 21 }

%complex_type = type { %complex_type*, half, %complex_type addrspace(1)* }

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

define i32 @load_i32_reg() {
; CHECK-LABEL: define i32 @load_i32_reg() {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    ret i32 [[TMP1]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %val = load i32, i32* %addr
  ret i32 %val
}

define i32 @load_i32_reg2() {
; CHECK-LABEL: define i32 @load_i32_reg2() {
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 4
; CHECK-NEXT:    ret i32 [[TMP1]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  %val = load i32, i32* %addr
  ret i32 %val
}

define i32 @load_i32_mem() {
; CHECK-LABEL: define i32 @load_i32_mem() {
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 15
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    ret i32 [[TMP4]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %val = load i32, i32* %addr
  ret i32 %val
}

define i32 @load_i32_dyn(i32 %i) {
; CHECK-LABEL: define i32 @load_i32_dyn(
; CHECK-SAME: i32 [[I:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP4:%.*]] = addrspacecast ptr [[ADDR]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr addrspace(20) [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP5]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i32 [[TMP6]], 60
; CHECK-NEXT:    br i1 [[TMP7]], label [[TMP8:%.*]], label [[TMP10:%.*]]
; CHECK:       8:
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr addrspace(20) [[TMP4]], align 4
; CHECK-NEXT:    br label [[TMP12:%.*]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    br label [[TMP12]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = phi i32 [ [[TMP9]], [[TMP8]] ], [ [[TMP11]], [[TMP10]] ]
; CHECK-NEXT:    ret i32 [[TMP13]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %val = load i32, i32* %addr
  ret i32 %val
}

define i64 @load_i64_reg() {
; CHECK-LABEL: define i64 @load_i64_reg() {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 44) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP2]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_INSERT_1]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i64, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret i64 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr64 = bitcast i32* %addr to i64*
  %val = load i64, i64* %addr64
  ret i64 %val
}

define i64 @load_i64_mem() {
; CHECK-LABEL: define i64 @load_i64_mem() {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 14
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP4]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr addrspace(21) [[TMP5]], align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP6]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_INSERT_1]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i64, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret i64 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  %addr64 = bitcast i32* %addr to i64*
  %val = load i64, i64* %addr64
  ret i64 %val
}

define i64 @load_i64_dyn(i32 %i) {
; CHECK-LABEL: define i64 @load_i64_dyn(
; CHECK-SAME: i32 [[I:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP4:%.*]] = addrspacecast ptr [[ADDR]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr addrspace(20) [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP5]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i32 [[TMP6]], 60
; CHECK-NEXT:    br i1 [[TMP7]], label [[TMP8:%.*]], label [[TMP10:%.*]]
; CHECK:       8:
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr addrspace(20) [[TMP4]], align 4
; CHECK-NEXT:    br label [[TMP12:%.*]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    br label [[TMP12]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = phi i32 [ [[TMP9]], [[TMP8]] ], [ [[TMP11]], [[TMP10]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP13]], 0
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, ptr [[ADDR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP15:%.*]] = addrspacecast ptr [[VAL_FCA_GEP_1]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr addrspace(20) [[TMP15]] to i32
; CHECK-NEXT:    [[TMP17:%.*]] = sub i32 [[TMP16]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP18:%.*]] = icmp ult i32 [[TMP17]], 60
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[TMP21:%.*]]
; CHECK:       19:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr addrspace(20) [[TMP15]], align 4
; CHECK-NEXT:    br label [[TMP23:%.*]]
; CHECK:       21:
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, ptr addrspace(21) [[TMP14]], align 4
; CHECK-NEXT:    br label [[TMP23]]
; CHECK:       23:
; CHECK-NEXT:    [[TMP24:%.*]] = phi i32 [ [[TMP20]], [[TMP19]] ], [ [[TMP22]], [[TMP21]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP24]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_INSERT_1]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i64, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret i64 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %addr64 = bitcast i32* %addr to i64*
  %val = load i64, i64* %addr64
  ret i64 %val
}

define i32 @store_i32_reg(i32 %val) {
; CHECK-LABEL: define i32 @store_i32_reg(
; CHECK-SAME: i32 [[VAL:%.*]]) {
; CHECK-NEXT:    store i32 [[VAL]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @store_i32_reg2(i32 %val) {
; CHECK-LABEL: define i32 @store_i32_reg2(
; CHECK-SAME: i32 [[VAL:%.*]]) {
; CHECK-NEXT:    store i32 [[VAL]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @store_i32_mem(i32 %val) {
; CHECK-LABEL: define i32 @store_i32_mem(
; CHECK-SAME: i32 [[VAL:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 15
; CHECK-NEXT:    store i32 [[VAL]], ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @store_i32_dyn(i32 %val, i32 %i) {
; CHECK-LABEL: define i32 @store_i32_dyn(
; CHECK-SAME: i32 [[VAL:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP4:%.*]] = addrspacecast ptr [[ADDR]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr addrspace(20) [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP5]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i32 [[TMP6]], 60
; CHECK-NEXT:    br i1 [[TMP7]], label [[TMP8:%.*]], label [[TMP9:%.*]]
; CHECK:       8:
; CHECK-NEXT:    store i32 [[VAL]], ptr addrspace(20) [[TMP4]], align 4
; CHECK-NEXT:    br label [[TMP10:%.*]]
; CHECK:       9:
; CHECK-NEXT:    store i32 [[VAL]], ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    br label [[TMP10]]
; CHECK:       10:
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @load_unaligned_i32_reg() {
; CHECK-LABEL: define i32 @load_unaligned_i32_reg() {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 41) to ptr addrspace(20)), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP2]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 42) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP3]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 43) to ptr addrspace(20)), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP4]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @load_unaligned_i32_reg2() {
; CHECK-LABEL: define i32 @load_unaligned_i32_reg2() {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 57) to ptr addrspace(20)), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP2]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 58) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP3]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 59) to ptr addrspace(20)), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP4]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @load_unaligned_i32_mem() {
; CHECK-LABEL: define i32 @load_unaligned_i32_mem() {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 15
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, ptr addrspace(21) [[TMP3]], align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP4]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i8, ptr addrspace(21) [[TMP5]], align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP6]], 1
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    [[TMP8:%.*]] = load i8, ptr addrspace(21) [[TMP7]], align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP8]], 2
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 3
; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr addrspace(21) [[TMP9]], align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP10]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @load_unaligned_i32_dyn(i32 %i) {
; CHECK-LABEL: define i32 @load_unaligned_i32_dyn(
; CHECK-SAME: i32 [[I:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP4:%.*]] = addrspacecast ptr [[ADDR]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr addrspace(20) [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP5]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i32 [[TMP6]], 60
; CHECK-NEXT:    br i1 [[TMP7]], label [[TMP8:%.*]], label [[TMP10:%.*]]
; CHECK:       8:
; CHECK-NEXT:    [[TMP9:%.*]] = load i8, ptr addrspace(20) [[TMP4]], align 2
; CHECK-NEXT:    br label [[TMP12:%.*]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr addrspace(21) [[TMP3]], align 2
; CHECK-NEXT:    br label [[TMP12]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = phi i8 [ [[TMP9]], [[TMP8]] ], [ [[TMP11]], [[TMP10]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP13]], 0
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_GEP_1:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, ptr [[ADDR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP15:%.*]] = addrspacecast ptr [[VAL_FCA_GEP_1]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr addrspace(20) [[TMP15]] to i32
; CHECK-NEXT:    [[TMP17:%.*]] = sub i32 [[TMP16]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP18:%.*]] = icmp ult i32 [[TMP17]], 60
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[TMP21:%.*]]
; CHECK:       19:
; CHECK-NEXT:    [[TMP20:%.*]] = load i8, ptr addrspace(20) [[TMP15]], align 1
; CHECK-NEXT:    br label [[TMP23:%.*]]
; CHECK:       21:
; CHECK-NEXT:    [[TMP22:%.*]] = load i8, ptr addrspace(21) [[TMP14]], align 1
; CHECK-NEXT:    br label [[TMP23]]
; CHECK:       23:
; CHECK-NEXT:    [[TMP24:%.*]] = phi i8 [ [[TMP20]], [[TMP19]] ], [ [[TMP22]], [[TMP21]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP24]], 1
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_GEP_2:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, ptr [[ADDR]], i32 0, i32 2
; CHECK-NEXT:    [[TMP26:%.*]] = addrspacecast ptr [[VAL_FCA_GEP_2]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP27:%.*]] = ptrtoint ptr addrspace(20) [[TMP26]] to i32
; CHECK-NEXT:    [[TMP28:%.*]] = sub i32 [[TMP27]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP29:%.*]] = icmp ult i32 [[TMP28]], 60
; CHECK-NEXT:    br i1 [[TMP29]], label [[TMP30:%.*]], label [[TMP32:%.*]]
; CHECK:       30:
; CHECK-NEXT:    [[TMP31:%.*]] = load i8, ptr addrspace(20) [[TMP26]], align 2
; CHECK-NEXT:    br label [[TMP34:%.*]]
; CHECK:       32:
; CHECK-NEXT:    [[TMP33:%.*]] = load i8, ptr addrspace(21) [[TMP25]], align 2
; CHECK-NEXT:    br label [[TMP34]]
; CHECK:       34:
; CHECK-NEXT:    [[TMP35:%.*]] = phi i8 [ [[TMP31]], [[TMP30]] ], [ [[TMP33]], [[TMP32]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP35]], 2
; CHECK-NEXT:    [[TMP36:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_GEP_3:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, ptr [[ADDR]], i32 0, i32 3
; CHECK-NEXT:    [[TMP37:%.*]] = addrspacecast ptr [[VAL_FCA_GEP_3]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP38:%.*]] = ptrtoint ptr addrspace(20) [[TMP37]] to i32
; CHECK-NEXT:    [[TMP39:%.*]] = sub i32 [[TMP38]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP40:%.*]] = icmp ult i32 [[TMP39]], 60
; CHECK-NEXT:    br i1 [[TMP40]], label [[TMP41:%.*]], label [[TMP43:%.*]]
; CHECK:       41:
; CHECK-NEXT:    [[TMP42:%.*]] = load i8, ptr addrspace(20) [[TMP37]], align 1
; CHECK-NEXT:    br label [[TMP45:%.*]]
; CHECK:       43:
; CHECK-NEXT:    [[TMP44:%.*]] = load i8, ptr addrspace(21) [[TMP36]], align 1
; CHECK-NEXT:    br label [[TMP45]]
; CHECK:       45:
; CHECK-NEXT:    [[TMP46:%.*]] = phi i8 [ [[TMP42]], [[TMP41]] ], [ [[TMP44]], [[TMP43]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP46]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @store_unaligned_i32_reg(i32 %val) {
; CHECK-LABEL: define i32 @store_unaligned_i32_reg(
; CHECK-SAME: i32 [[VAL:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    store i32 [[VAL]], ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <{ i8, i8, i8, i8 }>, ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_0:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_1:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 41) to ptr addrspace(20)), align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_2:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 2
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 42) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_3:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 3
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 43) to ptr addrspace(20)), align 1
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  store i32 %val, i32* %addr, align 2
  ret i32 %val
}

define i32 @store_unaligned_i32_mem(i32 %val) {
; CHECK-LABEL: define i32 @store_unaligned_i32_mem(
; CHECK-SAME: i32 [[VAL:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    store i32 [[VAL]], ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <{ i8, i8, i8, i8 }>, ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_0:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_1:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 57) to ptr addrspace(20)), align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_2:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 2
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 58) to ptr addrspace(20)), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_3:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 3
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 59) to ptr addrspace(20)), align 1
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  store i32 %val, i32* %addr, align 2
  ret i32 %val
}

define i32 @store_unaligned_i32_dyn(i32 %val, i32 %i) {
; CHECK-LABEL: define i32 @store_unaligned_i32_dyn(
; CHECK-SAME: i32 [[VAL:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i32 0, i32 [[I]]
; CHECK-NEXT:    store i32 [[VAL]], ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <{ i8, i8, i8, i8 }>, ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_0:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = addrspacecast ptr [[ADDR]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr addrspace(20) [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP5]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i32 [[TMP6]], 60
; CHECK-NEXT:    br i1 [[TMP7]], label [[TMP8:%.*]], label [[TMP9:%.*]]
; CHECK:       8:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], ptr addrspace(20) [[TMP4]], align 2
; CHECK-NEXT:    br label [[TMP10:%.*]]
; CHECK:       9:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], ptr addrspace(21) [[TMP3]], align 2
; CHECK-NEXT:    br label [[TMP10]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_GEP_1:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, ptr [[ADDR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_1:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 1
; CHECK-NEXT:    [[TMP12:%.*]] = addrspacecast ptr [[VAL_FCA_GEP_1]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr addrspace(20) [[TMP12]] to i32
; CHECK-NEXT:    [[TMP14:%.*]] = sub i32 [[TMP13]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP15:%.*]] = icmp ult i32 [[TMP14]], 60
; CHECK-NEXT:    br i1 [[TMP15]], label [[TMP16:%.*]], label [[TMP17:%.*]]
; CHECK:       16:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], ptr addrspace(20) [[TMP12]], align 1
; CHECK-NEXT:    br label [[TMP18:%.*]]
; CHECK:       17:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], ptr addrspace(21) [[TMP11]], align 1
; CHECK-NEXT:    br label [[TMP18]]
; CHECK:       18:
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_GEP_2:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, ptr [[ADDR]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_2:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 2
; CHECK-NEXT:    [[TMP20:%.*]] = addrspacecast ptr [[VAL_FCA_GEP_2]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP21:%.*]] = ptrtoint ptr addrspace(20) [[TMP20]] to i32
; CHECK-NEXT:    [[TMP22:%.*]] = sub i32 [[TMP21]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ult i32 [[TMP22]], 60
; CHECK-NEXT:    br i1 [[TMP23]], label [[TMP24:%.*]], label [[TMP25:%.*]]
; CHECK:       24:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], ptr addrspace(20) [[TMP20]], align 2
; CHECK-NEXT:    br label [[TMP26:%.*]]
; CHECK:       25:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], ptr addrspace(21) [[TMP19]], align 2
; CHECK-NEXT:    br label [[TMP26]]
; CHECK:       26:
; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_GEP_3:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, ptr [[ADDR]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_3:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 3
; CHECK-NEXT:    [[TMP28:%.*]] = addrspacecast ptr [[VAL_FCA_GEP_3]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP29:%.*]] = ptrtoint ptr addrspace(20) [[TMP28]] to i32
; CHECK-NEXT:    [[TMP30:%.*]] = sub i32 [[TMP29]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP31:%.*]] = icmp ult i32 [[TMP30]], 60
; CHECK-NEXT:    br i1 [[TMP31]], label [[TMP32:%.*]], label [[TMP33:%.*]]
; CHECK:       32:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], ptr addrspace(20) [[TMP28]], align 1
; CHECK-NEXT:    br label [[TMP34:%.*]]
; CHECK:       33:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], ptr addrspace(21) [[TMP27]], align 1
; CHECK-NEXT:    br label [[TMP34]]
; CHECK:       34:
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  store i32 %val, i32* %addr, align 2
  ret i32 %val
}

define %complex_type @load_struct_reg() {
; CHECK-LABEL: define %complex_type @load_struct_reg() {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 44) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP2]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load ptr, ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE:%.*]] poison, ptr [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = load half, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 48) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP3]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 52) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP4]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP5]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load ptr addrspace(1), ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], ptr addrspace(1) [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @load_struct_mem() {
; CHECK-LABEL: define %complex_type @load_struct_mem() {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 15
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP4]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, ptr addrspace(21) [[TMP5]], align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP6]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load ptr, ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE:%.*]] poison, ptr [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[TMP8:%.*]] = load half, ptr addrspace(21) [[TMP7]], align 4
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP8]], 1
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, ptr addrspace(21) [[TMP9]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP10]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP9]], i32 0, i32 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, ptr addrspace(21) [[TMP11]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP12]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load ptr addrspace(1), ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], ptr addrspace(1) [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @load_struct_both() {
; CHECK-LABEL: define %complex_type @load_struct_both() {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 13
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 52) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP4]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP5]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load ptr, ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE:%.*]] poison, ptr [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[TMP7:%.*]] = load half, ptr addrspace(21) [[TMP6]], align 4
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP7]], 1
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr addrspace(21) [[TMP8]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP9]], 0
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP8]], i32 0, i32 1
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr addrspace(21) [[TMP10]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP11]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load ptr addrspace(1), ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], ptr addrspace(1) [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 13
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @load_struct_dyn(i32 %i) {
; CHECK-LABEL: define %complex_type @load_struct_dyn(
; CHECK-SAME: i32 [[I:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP4:%.*]] = addrspacecast ptr [[ADDR]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr addrspace(20) [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP5]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i32 [[TMP6]], 60
; CHECK-NEXT:    br i1 [[TMP7]], label [[TMP8:%.*]], label [[TMP10:%.*]]
; CHECK:       8:
; CHECK-NEXT:    [[TMP9:%.*]] = load i32, ptr addrspace(20) [[TMP4]], align 4
; CHECK-NEXT:    br label [[TMP12:%.*]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    br label [[TMP12]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = phi i32 [ [[TMP9]], [[TMP8]] ], [ [[TMP11]], [[TMP10]] ]
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP13]], 0
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, ptr [[ADDR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP15:%.*]] = addrspacecast ptr [[VAL_FCA_0_GEP_1]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP16:%.*]] = ptrtoint ptr addrspace(20) [[TMP15]] to i32
; CHECK-NEXT:    [[TMP17:%.*]] = sub i32 [[TMP16]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP18:%.*]] = icmp ult i32 [[TMP17]], 60
; CHECK-NEXT:    br i1 [[TMP18]], label [[TMP19:%.*]], label [[TMP21:%.*]]
; CHECK:       19:
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, ptr addrspace(20) [[TMP15]], align 4
; CHECK-NEXT:    br label [[TMP23:%.*]]
; CHECK:       21:
; CHECK-NEXT:    [[TMP22:%.*]] = load i32, ptr addrspace(21) [[TMP14]], align 4
; CHECK-NEXT:    br label [[TMP23]]
; CHECK:       23:
; CHECK-NEXT:    [[TMP24:%.*]] = phi i32 [ [[TMP20]], [[TMP19]] ], [ [[TMP22]], [[TMP21]] ]
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP24]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load ptr, ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE:%.*]] poison, ptr [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], ptr [[ADDR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP26:%.*]] = addrspacecast ptr [[VAL_FCA_1_GEP]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP27:%.*]] = ptrtoint ptr addrspace(20) [[TMP26]] to i32
; CHECK-NEXT:    [[TMP28:%.*]] = sub i32 [[TMP27]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP29:%.*]] = icmp ult i32 [[TMP28]], 60
; CHECK-NEXT:    br i1 [[TMP29]], label [[TMP30:%.*]], label [[TMP32:%.*]]
; CHECK:       30:
; CHECK-NEXT:    [[TMP31:%.*]] = load half, ptr addrspace(20) [[TMP26]], align 4
; CHECK-NEXT:    br label [[TMP34:%.*]]
; CHECK:       32:
; CHECK-NEXT:    [[TMP33:%.*]] = load half, ptr addrspace(21) [[TMP25]], align 4
; CHECK-NEXT:    br label [[TMP34]]
; CHECK:       34:
; CHECK-NEXT:    [[TMP35:%.*]] = phi half [ [[TMP31]], [[TMP30]] ], [ [[TMP33]], [[TMP32]] ]
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP35]], 1
; CHECK-NEXT:    [[TMP36:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], ptr [[ADDR]], i32 0, i32 2
; CHECK-NEXT:    [[TMP37:%.*]] = addrspacecast ptr [[VAL_FCA_2_GEP]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP38:%.*]] = ptrtoint ptr addrspace(20) [[TMP37]] to i32
; CHECK-NEXT:    [[TMP39:%.*]] = sub i32 [[TMP38]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP40:%.*]] = icmp ult i32 [[TMP39]], 60
; CHECK-NEXT:    br i1 [[TMP40]], label [[TMP41:%.*]], label [[TMP43:%.*]]
; CHECK:       41:
; CHECK-NEXT:    [[TMP42:%.*]] = load i32, ptr addrspace(20) [[TMP37]], align 4
; CHECK-NEXT:    br label [[TMP45:%.*]]
; CHECK:       43:
; CHECK-NEXT:    [[TMP44:%.*]] = load i32, ptr addrspace(21) [[TMP36]], align 4
; CHECK-NEXT:    br label [[TMP45]]
; CHECK:       45:
; CHECK-NEXT:    [[TMP46:%.*]] = phi i32 [ [[TMP42]], [[TMP41]] ], [ [[TMP44]], [[TMP43]] ]
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP46]], 0
; CHECK-NEXT:    [[TMP47:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP36]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, ptr [[VAL_FCA_2_GEP]], i32 0, i32 1
; CHECK-NEXT:    [[TMP48:%.*]] = addrspacecast ptr [[VAL_FCA_2_GEP_1]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP49:%.*]] = ptrtoint ptr addrspace(20) [[TMP48]] to i32
; CHECK-NEXT:    [[TMP50:%.*]] = sub i32 [[TMP49]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP51:%.*]] = icmp ult i32 [[TMP50]], 60
; CHECK-NEXT:    br i1 [[TMP51]], label [[TMP52:%.*]], label [[TMP54:%.*]]
; CHECK:       52:
; CHECK-NEXT:    [[TMP53:%.*]] = load i32, ptr addrspace(20) [[TMP48]], align 4
; CHECK-NEXT:    br label [[TMP56:%.*]]
; CHECK:       54:
; CHECK-NEXT:    [[TMP55:%.*]] = load i32, ptr addrspace(21) [[TMP47]], align 4
; CHECK-NEXT:    br label [[TMP56]]
; CHECK:       56:
; CHECK-NEXT:    [[TMP57:%.*]] = phi i32 [ [[TMP53]], [[TMP52]] ], [ [[TMP55]], [[TMP54]] ]
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP57]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load ptr addrspace(1), ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], ptr addrspace(1) [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_reg(%complex_type %val) {
; CHECK-LABEL: define %complex_type @store_struct_reg(
; CHECK-SAME: [[COMPLEX_TYPE:%.*]] [[VAL:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 0
; CHECK-NEXT:    store ptr [[VAL_FCA_0_EXTRACT]], ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 44) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 48) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    store ptr addrspace(1) [[VAL_FCA_2_EXTRACT]], ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 52) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 4
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_mem(%complex_type %val) {
; CHECK-LABEL: define %complex_type @store_struct_mem(
; CHECK-SAME: [[COMPLEX_TYPE:%.*]] [[VAL:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 15
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 0
; CHECK-NEXT:    store ptr [[VAL_FCA_0_EXTRACT]], ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], ptr addrspace(21) [[TMP4]], align 4
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], ptr addrspace(21) [[TMP5]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    store ptr addrspace(1) [[VAL_FCA_2_EXTRACT]], ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], ptr addrspace(21) [[TMP6]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], ptr addrspace(21) [[TMP7]], align 4
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_both(%complex_type %val) {
; CHECK-LABEL: define %complex_type @store_struct_both(
; CHECK-SAME: [[COMPLEX_TYPE:%.*]] [[VAL:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 13
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 0
; CHECK-NEXT:    store ptr [[VAL_FCA_0_EXTRACT]], ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 52) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 56) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], ptr addrspace(21) [[TMP4]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    store ptr addrspace(1) [[VAL_FCA_2_EXTRACT]], ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], ptr addrspace(21) [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP5]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], ptr addrspace(21) [[TMP6]], align 4
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 13
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_dyn(%complex_type %val, i32 %i) {
; CHECK-LABEL: define %complex_type @store_struct_dyn(
; CHECK-SAME: [[COMPLEX_TYPE:%.*]] [[VAL:%.*]], i32 [[I:%.*]]) {
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(21) @registerbuffer.getpointer.a15i32(ptr addrspace(20) @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, ptr addrspace(21) [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [20 x i32], ptr addrspace(21) [[TMP2]], i32 0, i32 [[I]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i32 0, i32 [[I]]
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 0
; CHECK-NEXT:    store ptr [[VAL_FCA_0_EXTRACT]], ptr [[VAL_FCA_0_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP4:%.*]] = addrspacecast ptr [[ADDR]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr addrspace(20) [[TMP4]] to i32
; CHECK-NEXT:    [[TMP6:%.*]] = sub i32 [[TMP5]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i32 [[TMP6]], 60
; CHECK-NEXT:    br i1 [[TMP7]], label [[TMP8:%.*]], label [[TMP9:%.*]]
; CHECK:       8:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], ptr addrspace(20) [[TMP4]], align 4
; CHECK-NEXT:    br label [[TMP10:%.*]]
; CHECK:       9:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], ptr addrspace(21) [[TMP3]], align 4
; CHECK-NEXT:    br label [[TMP10]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, ptr [[ADDR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    [[TMP12:%.*]] = addrspacecast ptr [[VAL_FCA_0_GEP_1]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP13:%.*]] = ptrtoint ptr addrspace(20) [[TMP12]] to i32
; CHECK-NEXT:    [[TMP14:%.*]] = sub i32 [[TMP13]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP15:%.*]] = icmp ult i32 [[TMP14]], 60
; CHECK-NEXT:    br i1 [[TMP15]], label [[TMP16:%.*]], label [[TMP17:%.*]]
; CHECK:       16:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], ptr addrspace(20) [[TMP12]], align 4
; CHECK-NEXT:    br label [[TMP18:%.*]]
; CHECK:       17:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], ptr addrspace(21) [[TMP11]], align 4
; CHECK-NEXT:    br label [[TMP18]]
; CHECK:       18:
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], ptr [[ADDR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP20:%.*]] = addrspacecast ptr [[VAL_FCA_1_GEP]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP21:%.*]] = ptrtoint ptr addrspace(20) [[TMP20]] to i32
; CHECK-NEXT:    [[TMP22:%.*]] = sub i32 [[TMP21]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ult i32 [[TMP22]], 60
; CHECK-NEXT:    br i1 [[TMP23]], label [[TMP24:%.*]], label [[TMP25:%.*]]
; CHECK:       24:
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], ptr addrspace(20) [[TMP20]], align 4
; CHECK-NEXT:    br label [[TMP26:%.*]]
; CHECK:       25:
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], ptr addrspace(21) [[TMP19]], align 4
; CHECK-NEXT:    br label [[TMP26]]
; CHECK:       26:
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr [[COMPLEX_TYPE]], ptr addrspace(21) [[TMP3]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], ptr [[ADDR]], i32 0, i32 2
; CHECK-NEXT:    store ptr addrspace(1) [[VAL_FCA_2_EXTRACT]], ptr [[VAL_FCA_2_ALLOCA]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, ptr [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP28:%.*]] = addrspacecast ptr [[VAL_FCA_2_GEP]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP29:%.*]] = ptrtoint ptr addrspace(20) [[TMP28]] to i32
; CHECK-NEXT:    [[TMP30:%.*]] = sub i32 [[TMP29]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP31:%.*]] = icmp ult i32 [[TMP30]], 60
; CHECK-NEXT:    br i1 [[TMP31]], label [[TMP32:%.*]], label [[TMP33:%.*]]
; CHECK:       32:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], ptr addrspace(20) [[TMP28]], align 4
; CHECK-NEXT:    br label [[TMP34:%.*]]
; CHECK:       33:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], ptr addrspace(21) [[TMP27]], align 4
; CHECK-NEXT:    br label [[TMP34]]
; CHECK:       34:
; CHECK-NEXT:    [[TMP35:%.*]] = getelementptr <{ i32, i32 }>, ptr addrspace(21) [[TMP27]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, ptr [[VAL_FCA_2_GEP]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    [[TMP36:%.*]] = addrspacecast ptr [[VAL_FCA_2_GEP_1]] to ptr addrspace(20)
; CHECK-NEXT:    [[TMP37:%.*]] = ptrtoint ptr addrspace(20) [[TMP36]] to i32
; CHECK-NEXT:    [[TMP38:%.*]] = sub i32 [[TMP37]], ptrtoint (ptr addrspace(20) @GLOBAL to i32)
; CHECK-NEXT:    [[TMP39:%.*]] = icmp ult i32 [[TMP38]], 60
; CHECK-NEXT:    br i1 [[TMP39]], label [[TMP40:%.*]], label [[TMP41:%.*]]
; CHECK:       40:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], ptr addrspace(20) [[TMP36]], align 4
; CHECK-NEXT:    br label [[TMP42:%.*]]
; CHECK:       41:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], ptr addrspace(21) [[TMP35]], align 4
; CHECK-NEXT:    br label [[TMP42]]
; CHECK:       42:
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define <3 x float> @load_v3float_reg() {
; CHECK-LABEL: define <3 x float> @load_v3float_reg() {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32, i32 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 44) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP2]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 48) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i32, i32, i32 }> [[VAL_FCA_INSERT_1]], i32 [[TMP3]], 2
; CHECK-NEXT:    store <{ i32, i32, i32 }> [[VAL_FCA_INSERT_2]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <3 x float>, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret <3 x float> [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to <3 x float>*
  %val = load <3 x float>, <3 x float>* %addr_type
  ret <3 x float> %val
}

define <3 x half> @load_v3half_reg() {
; CHECK-LABEL: define <3 x half> @load_v3half_reg() {
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i16 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i16 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i16, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 44) to ptr addrspace(20)), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i16 }> [[VAL_FCA_INSERT_0]], i16 [[TMP2]], 1
; CHECK-NEXT:    store <{ i32, i16 }> [[VAL_FCA_INSERT_1]], ptr [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <3 x half>, ptr [[VAL_FCA_ALLOCA]], align 8
; CHECK-NEXT:    ret <3 x half> [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to <3 x half>*
  %val = load <3 x half>, <3 x half>* %addr_type
  ret <3 x half> %val
}

define <3 x i8> @load_v3i8_reg() {
; CHECK-LABEL: define <3 x i8> @load_v3i8_reg() {
; CHECK-NEXT:    [[TMP1:%.*]] = load <3 x i8>, ptr addrspace(20) addrspacecast (ptr getelementptr (i8, ptr addrspacecast (ptr addrspace(20) @GLOBAL to ptr), i64 40) to ptr addrspace(20)), align 4
; CHECK-NEXT:    ret <3 x i8> [[TMP1]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to <3 x i8>*
  %val = load <3 x i8>, <3 x i8>* %addr_type
  ret <3 x i8> %val
}

define void @with_lifetime_intrinsics() {
; CHECK-LABEL: define void @with_lifetime_intrinsics() {
; CHECK-NEXT:    ret void
;
  %ptr = bitcast [20 x i32]* @GLOBAL to i8*
  call void @llvm.lifetime.start.p0i8(i64 80, i8* %ptr)
  call void @llvm.lifetime.end.p0i8(i64 80, i8* %ptr)
  ret void
}
