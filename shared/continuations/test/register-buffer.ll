; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt --opaque-pointers=0 --enforce-pointer-metadata=1 --verify-each -passes='add-types-metadata,register-buffer,lint,instsimplify,remove-types-metadata' -S %s 2>%t.stderr | FileCheck %s
; RUN: count 0 < %t.stderr

target datalayout = "e-m:e-p:64:32-p20:32:32-p21:32:32-i1:32-i8:8-i16:32-i32:32-i64:32-f16:32-f32:32-f64:32-v16:32-v32:32-v48:32-v64:32-v80:32-v96:32-v112:32-v128:32-v144:32-v160:32-v176:32-v192:32-v208:32-v224:32-v240:32-v256:32-n8:16:32"

; CHECK: @GLOBAL = external addrspace(20) global [15 x i32]
@GLOBAL = external global [20 x i32], !registerbuffer !1
!1 = !{ i32 15, i32 21 }

%complex_type = type { %complex_type*, half, %complex_type addrspace(1)* }

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

define i32 @load_i32_reg() {
; CHECK-LABEL: @load_i32_reg(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    ret i32 [[TMP1]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %val = load i32, i32* %addr
  ret i32 %val
}

define i32 @load_i32_reg2() {
; CHECK-LABEL: @load_i32_reg2(
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    ret i32 [[TMP1]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  %val = load i32, i32* %addr
  ret i32 %val
}

define i32 @load_i32_mem() {
; CHECK-LABEL: @load_i32_mem(
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 15
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, i32 addrspace(21)* [[TMP5]], align 4
; CHECK-NEXT:    ret i32 [[TMP6]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %val = load i32, i32* %addr
  ret i32 %val
}

define i32 @load_i32_dyn(i32 %i) {
; CHECK-LABEL: @load_i32_dyn(
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 [[I:%.*]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], [20 x i32]* addrspacecast ([20 x i32] addrspace(20)* bitcast ([15 x i32] addrspace(20)* @GLOBAL to [20 x i32] addrspace(20)*) to [20 x i32]*), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP6:%.*]] = addrspacecast i32* [[ADDR]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP7:%.*]] = ptrtoint i32 addrspace(20)* [[TMP6]] to i32
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[TMP7]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP9:%.*]] = icmp ult i32 [[TMP8]], 60
; CHECK-NEXT:    br i1 [[TMP9]], label [[TMP10:%.*]], label [[TMP12:%.*]]
; CHECK:       10:
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, i32 addrspace(20)* [[TMP6]], align 4
; CHECK-NEXT:    br label [[TMP14:%.*]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = load i32, i32 addrspace(21)* [[TMP5]], align 4
; CHECK-NEXT:    br label [[TMP14]]
; CHECK:       14:
; CHECK-NEXT:    [[TMP15:%.*]] = phi i32 [ [[TMP11]], [[TMP10]] ], [ [[TMP13]], [[TMP12]] ]
; CHECK-NEXT:    ret i32 [[TMP15]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %val = load i32, i32* %addr
  ret i32 %val
}

define i64 @load_i64_reg() {
; CHECK-LABEL: @load_i64_reg(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 11) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP2]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_ALLOCA]] to i64*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i64, i64* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret i64 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr64 = bitcast i32* %addr to i64*
  %val = load i64, i64* %addr64
  ret i64 %val
}

define i64 @load_i64_mem() {
; CHECK-LABEL: @load_i64_mem(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 14
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to i64 addrspace(21)*
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i64 addrspace(21)* [[TMP6]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP8]], 0
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP7]], i32 0, i32 1
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, i32 addrspace(21)* [[TMP9]], align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP10]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_ALLOCA]] to i64*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i64, i64* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret i64 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  %addr64 = bitcast i32* %addr to i64*
  %val = load i64, i64* %addr64
  ret i64 %val
}

define i64 @load_i64_dyn(i32 %i) {
; CHECK-LABEL: @load_i64_dyn(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 [[I:%.*]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], [20 x i32]* addrspacecast ([20 x i32] addrspace(20)* bitcast ([15 x i32] addrspace(20)* @GLOBAL to [20 x i32] addrspace(20)*) to [20 x i32]*), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to i64 addrspace(21)*
; CHECK-NEXT:    [[ADDR64:%.*]] = bitcast i32* [[ADDR]] to i64*
; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i64 addrspace(21)* [[TMP6]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_PTR:%.*]] = bitcast i64* [[ADDR64]] to <{ i32, i32 }>*
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP7]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_GEP_0:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_PTR]], i32 0, i32 0
; CHECK-NEXT:    [[TMP9:%.*]] = addrspacecast i32* [[VAL_FCA_GEP_0]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP10:%.*]] = ptrtoint i32 addrspace(20)* [[TMP9]] to i32
; CHECK-NEXT:    [[TMP11:%.*]] = sub i32 [[TMP10]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP12:%.*]] = icmp ult i32 [[TMP11]], 60
; CHECK-NEXT:    br i1 [[TMP12]], label [[TMP13:%.*]], label [[TMP15:%.*]]
; CHECK:       13:
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, i32 addrspace(20)* [[TMP9]], align 4
; CHECK-NEXT:    br label [[TMP17:%.*]]
; CHECK:       15:
; CHECK-NEXT:    [[TMP16:%.*]] = load i32, i32 addrspace(21)* [[TMP8]], align 4
; CHECK-NEXT:    br label [[TMP17]]
; CHECK:       17:
; CHECK-NEXT:    [[TMP18:%.*]] = phi i32 [ [[TMP14]], [[TMP13]] ], [ [[TMP16]], [[TMP15]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP18]], 0
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP7]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_PTR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP20:%.*]] = addrspacecast i32* [[VAL_FCA_GEP_1]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP21:%.*]] = ptrtoint i32 addrspace(20)* [[TMP20]] to i32
; CHECK-NEXT:    [[TMP22:%.*]] = sub i32 [[TMP21]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP23:%.*]] = icmp ult i32 [[TMP22]], 60
; CHECK-NEXT:    br i1 [[TMP23]], label [[TMP24:%.*]], label [[TMP26:%.*]]
; CHECK:       24:
; CHECK-NEXT:    [[TMP25:%.*]] = load i32, i32 addrspace(20)* [[TMP20]], align 4
; CHECK-NEXT:    br label [[TMP28:%.*]]
; CHECK:       26:
; CHECK-NEXT:    [[TMP27:%.*]] = load i32, i32 addrspace(21)* [[TMP19]], align 4
; CHECK-NEXT:    br label [[TMP28]]
; CHECK:       28:
; CHECK-NEXT:    [[TMP29:%.*]] = phi i32 [ [[TMP25]], [[TMP24]] ], [ [[TMP27]], [[TMP26]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP29]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_ALLOCA]] to i64*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i64, i64* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret i64 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %addr64 = bitcast i32* %addr to i64*
  %val = load i64, i64* %addr64
  ret i64 %val
}

define i32 @store_i32_reg(i32 %val) {
; CHECK-LABEL: @store_i32_reg(
; CHECK-NEXT:    store i32 [[VAL:%.*]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @store_i32_reg2(i32 %val) {
; CHECK-LABEL: @store_i32_reg2(
; CHECK-NEXT:    store i32 [[VAL:%.*]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @store_i32_mem(i32 %val) {
; CHECK-LABEL: @store_i32_mem(
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 15
; CHECK-NEXT:    store i32 [[VAL:%.*]], i32 addrspace(21)* [[TMP5]], align 4
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @store_i32_dyn(i32 %val, i32 %i) {
; CHECK-LABEL: @store_i32_dyn(
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 [[I:%.*]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], [20 x i32]* addrspacecast ([20 x i32] addrspace(20)* bitcast ([15 x i32] addrspace(20)* @GLOBAL to [20 x i32] addrspace(20)*) to [20 x i32]*), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP6:%.*]] = addrspacecast i32* [[ADDR]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP7:%.*]] = ptrtoint i32 addrspace(20)* [[TMP6]] to i32
; CHECK-NEXT:    [[TMP8:%.*]] = sub i32 [[TMP7]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP9:%.*]] = icmp ult i32 [[TMP8]], 60
; CHECK-NEXT:    br i1 [[TMP9]], label [[TMP10:%.*]], label [[TMP11:%.*]]
; CHECK:       10:
; CHECK-NEXT:    store i32 [[VAL:%.*]], i32 addrspace(20)* [[TMP6]], align 4
; CHECK-NEXT:    br label [[TMP12:%.*]]
; CHECK:       11:
; CHECK-NEXT:    store i32 [[VAL]], i32 addrspace(21)* [[TMP5]], align 4
; CHECK-NEXT:    br label [[TMP12]]
; CHECK:       12:
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  store i32 %val, i32* %addr
  ret i32 %val
}

define i32 @load_unaligned_i32_reg() {
; CHECK-LABEL: @load_unaligned_i32_reg(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i8*) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to <{ i8, i8, i8, i8 }>*), i64 0, i32 1) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP2]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to <{ i8, i8, i8, i8 }>*), i64 0, i32 2) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP3]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to <{ i8, i8, i8, i8 }>*), i64 0, i32 3) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP4]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]] to i32*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, i32* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @load_unaligned_i32_reg2() {
; CHECK-LABEL: @load_unaligned_i32_reg2(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i8*) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to <{ i8, i8, i8, i8 }>*), i64 0, i32 1) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP2]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to <{ i8, i8, i8, i8 }>*), i64 0, i32 2) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP3]], 2
; CHECK-NEXT:    [[TMP4:%.*]] = load i8, i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to <{ i8, i8, i8, i8 }>*), i64 0, i32 3) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP4]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]] to i32*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, i32* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @load_unaligned_i32_mem() {
; CHECK-LABEL: @load_unaligned_i32_mem(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 15
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to <{ i8, i8, i8, i8 }> addrspace(21)*
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = load i8, i8 addrspace(21)* [[TMP7]], align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP8]], 0
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[TMP10:%.*]] = load i8, i8 addrspace(21)* [[TMP9]], align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP10]], 1
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[TMP12:%.*]] = load i8, i8 addrspace(21)* [[TMP11]], align 2
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP12]], 2
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 3
; CHECK-NEXT:    [[TMP14:%.*]] = load i8, i8 addrspace(21)* [[TMP13]], align 1
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP14]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]] to i32*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, i32* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @load_unaligned_i32_dyn(i32 %i) {
; CHECK-LABEL: @load_unaligned_i32_dyn(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 [[I:%.*]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], [20 x i32]* addrspacecast ([20 x i32] addrspace(20)* bitcast ([15 x i32] addrspace(20)* @GLOBAL to [20 x i32] addrspace(20)*) to [20 x i32]*), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to <{ i8, i8, i8, i8 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_PTR:%.*]] = bitcast i32* [[ADDR]] to <{ i8, i8, i8, i8 }>*
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_GEP_0:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_0]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP9:%.*]] = ptrtoint i8 addrspace(20)* [[TMP8]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = sub i32 [[TMP9]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP11:%.*]] = icmp ult i32 [[TMP10]], 60
; CHECK-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[TMP14:%.*]]
; CHECK:       12:
; CHECK-NEXT:    [[TMP13:%.*]] = load i8, i8 addrspace(20)* [[TMP8]], align 2
; CHECK-NEXT:    br label [[TMP16:%.*]]
; CHECK:       14:
; CHECK-NEXT:    [[TMP15:%.*]] = load i8, i8 addrspace(21)* [[TMP7]], align 2
; CHECK-NEXT:    br label [[TMP16]]
; CHECK:       16:
; CHECK-NEXT:    [[TMP17:%.*]] = phi i8 [ [[TMP13]], [[TMP12]] ], [ [[TMP15]], [[TMP14]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i8, i8, i8, i8 }> poison, i8 [[TMP17]], 0
; CHECK-NEXT:    [[TMP18:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_GEP_1:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP19:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_1]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP20:%.*]] = ptrtoint i8 addrspace(20)* [[TMP19]] to i32
; CHECK-NEXT:    [[TMP21:%.*]] = sub i32 [[TMP20]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP22:%.*]] = icmp ult i32 [[TMP21]], 60
; CHECK-NEXT:    br i1 [[TMP22]], label [[TMP23:%.*]], label [[TMP25:%.*]]
; CHECK:       23:
; CHECK-NEXT:    [[TMP24:%.*]] = load i8, i8 addrspace(20)* [[TMP19]], align 1
; CHECK-NEXT:    br label [[TMP27:%.*]]
; CHECK:       25:
; CHECK-NEXT:    [[TMP26:%.*]] = load i8, i8 addrspace(21)* [[TMP18]], align 1
; CHECK-NEXT:    br label [[TMP27]]
; CHECK:       27:
; CHECK-NEXT:    [[TMP28:%.*]] = phi i8 [ [[TMP24]], [[TMP23]] ], [ [[TMP26]], [[TMP25]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_0]], i8 [[TMP28]], 1
; CHECK-NEXT:    [[TMP29:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_GEP_2:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 2
; CHECK-NEXT:    [[TMP30:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_2]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP31:%.*]] = ptrtoint i8 addrspace(20)* [[TMP30]] to i32
; CHECK-NEXT:    [[TMP32:%.*]] = sub i32 [[TMP31]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP33:%.*]] = icmp ult i32 [[TMP32]], 60
; CHECK-NEXT:    br i1 [[TMP33]], label [[TMP34:%.*]], label [[TMP36:%.*]]
; CHECK:       34:
; CHECK-NEXT:    [[TMP35:%.*]] = load i8, i8 addrspace(20)* [[TMP30]], align 2
; CHECK-NEXT:    br label [[TMP38:%.*]]
; CHECK:       36:
; CHECK-NEXT:    [[TMP37:%.*]] = load i8, i8 addrspace(21)* [[TMP29]], align 2
; CHECK-NEXT:    br label [[TMP38]]
; CHECK:       38:
; CHECK-NEXT:    [[TMP39:%.*]] = phi i8 [ [[TMP35]], [[TMP34]] ], [ [[TMP37]], [[TMP36]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_1]], i8 [[TMP39]], 2
; CHECK-NEXT:    [[TMP40:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_GEP_3:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 3
; CHECK-NEXT:    [[TMP41:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_3]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP42:%.*]] = ptrtoint i8 addrspace(20)* [[TMP41]] to i32
; CHECK-NEXT:    [[TMP43:%.*]] = sub i32 [[TMP42]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP44:%.*]] = icmp ult i32 [[TMP43]], 60
; CHECK-NEXT:    br i1 [[TMP44]], label [[TMP45:%.*]], label [[TMP47:%.*]]
; CHECK:       45:
; CHECK-NEXT:    [[TMP46:%.*]] = load i8, i8 addrspace(20)* [[TMP41]], align 1
; CHECK-NEXT:    br label [[TMP49:%.*]]
; CHECK:       47:
; CHECK-NEXT:    [[TMP48:%.*]] = load i8, i8 addrspace(21)* [[TMP40]], align 1
; CHECK-NEXT:    br label [[TMP49]]
; CHECK:       49:
; CHECK-NEXT:    [[TMP50:%.*]] = phi i8 [ [[TMP46]], [[TMP45]] ], [ [[TMP48]], [[TMP47]] ]
; CHECK-NEXT:    [[VAL_FCA_INSERT_3:%.*]] = insertvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_2]], i8 [[TMP50]], 3
; CHECK-NEXT:    store <{ i8, i8, i8, i8 }> [[VAL_FCA_INSERT_3]], <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]] to i32*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load i32, i32* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret i32 [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %val = load i32, i32* %addr, align 2
  ret i32 %val
}

define i32 @store_unaligned_i32_reg(i32 %val) {
; CHECK-LABEL: @store_unaligned_i32_reg(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]] to i32*
; CHECK-NEXT:    store i32 [[VAL:%.*]], i32* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_0:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], i8 addrspace(20)* addrspacecast (i8* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i8*) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_1:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to <{ i8, i8, i8, i8 }>*), i64 0, i32 1) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_2:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 2
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to <{ i8, i8, i8, i8 }>*), i64 0, i32 2) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_3:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 3
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to <{ i8, i8, i8, i8 }>*), i64 0, i32 3) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  store i32 %val, i32* %addr, align 2
  ret i32 %val
}

define i32 @store_unaligned_i32_mem(i32 %val) {
; CHECK-LABEL: @store_unaligned_i32_mem(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]] to i32*
; CHECK-NEXT:    store i32 [[VAL:%.*]], i32* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_0:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], i8 addrspace(20)* addrspacecast (i8* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i8*) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_1:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to <{ i8, i8, i8, i8 }>*), i64 0, i32 1) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_2:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 2
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to <{ i8, i8, i8, i8 }>*), i64 0, i32 2) to i8 addrspace(20)*), align 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_3:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 3
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], i8 addrspace(20)* addrspacecast (i8* getelementptr inbounds (<{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to <{ i8, i8, i8, i8 }>*), i64 0, i32 3) to i8 addrspace(20)*), align 1
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 14
  store i32 %val, i32* %addr, align 2
  ret i32 %val
}

define i32 @store_unaligned_i32_dyn(i32 %val, i32 %i) {
; CHECK-LABEL: @store_unaligned_i32_dyn(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i8, i8, i8, i8 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 [[I:%.*]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], [20 x i32]* addrspacecast ([20 x i32] addrspace(20)* bitcast ([15 x i32] addrspace(20)* @GLOBAL to [20 x i32] addrspace(20)*) to [20 x i32]*), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to <{ i8, i8, i8, i8 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_PTR:%.*]] = bitcast i32* [[ADDR]] to <{ i8, i8, i8, i8 }>*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]] to i32*
; CHECK-NEXT:    store i32 [[VAL:%.*]], i32* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_GEP_0:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_0:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP8:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_0]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP9:%.*]] = ptrtoint i8 addrspace(20)* [[TMP8]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = sub i32 [[TMP9]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP11:%.*]] = icmp ult i32 [[TMP10]], 60
; CHECK-NEXT:    br i1 [[TMP11]], label [[TMP12:%.*]], label [[TMP13:%.*]]
; CHECK:       12:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], i8 addrspace(20)* [[TMP8]], align 2
; CHECK-NEXT:    br label [[TMP14:%.*]]
; CHECK:       13:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_0]], i8 addrspace(21)* [[TMP7]], align 2
; CHECK-NEXT:    br label [[TMP14]]
; CHECK:       14:
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_GEP_1:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_1:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 1
; CHECK-NEXT:    [[TMP16:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_1]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP17:%.*]] = ptrtoint i8 addrspace(20)* [[TMP16]] to i32
; CHECK-NEXT:    [[TMP18:%.*]] = sub i32 [[TMP17]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP19:%.*]] = icmp ult i32 [[TMP18]], 60
; CHECK-NEXT:    br i1 [[TMP19]], label [[TMP20:%.*]], label [[TMP21:%.*]]
; CHECK:       20:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], i8 addrspace(20)* [[TMP16]], align 1
; CHECK-NEXT:    br label [[TMP22:%.*]]
; CHECK:       21:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_1]], i8 addrspace(21)* [[TMP15]], align 1
; CHECK-NEXT:    br label [[TMP22]]
; CHECK:       22:
; CHECK-NEXT:    [[TMP23:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_GEP_2:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_2:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 2
; CHECK-NEXT:    [[TMP24:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_2]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP25:%.*]] = ptrtoint i8 addrspace(20)* [[TMP24]] to i32
; CHECK-NEXT:    [[TMP26:%.*]] = sub i32 [[TMP25]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP27:%.*]] = icmp ult i32 [[TMP26]], 60
; CHECK-NEXT:    br i1 [[TMP27]], label [[TMP28:%.*]], label [[TMP29:%.*]]
; CHECK:       28:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], i8 addrspace(20)* [[TMP24]], align 2
; CHECK-NEXT:    br label [[TMP30:%.*]]
; CHECK:       29:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_2]], i8 addrspace(21)* [[TMP23]], align 2
; CHECK-NEXT:    br label [[TMP30]]
; CHECK:       30:
; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }> addrspace(21)* [[TMP6]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_GEP_3:%.*]] = getelementptr inbounds <{ i8, i8, i8, i8 }>, <{ i8, i8, i8, i8 }>* [[VAL_FCA_PTR]], i32 0, i32 3
; CHECK-NEXT:    [[VAL_FCA_EXTRACT_3:%.*]] = extractvalue <{ i8, i8, i8, i8 }> [[VAL_FCA_ALLOCA_LOAD]], 3
; CHECK-NEXT:    [[TMP32:%.*]] = addrspacecast i8* [[VAL_FCA_GEP_3]] to i8 addrspace(20)*
; CHECK-NEXT:    [[TMP33:%.*]] = ptrtoint i8 addrspace(20)* [[TMP32]] to i32
; CHECK-NEXT:    [[TMP34:%.*]] = sub i32 [[TMP33]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP35:%.*]] = icmp ult i32 [[TMP34]], 60
; CHECK-NEXT:    br i1 [[TMP35]], label [[TMP36:%.*]], label [[TMP37:%.*]]
; CHECK:       36:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], i8 addrspace(20)* [[TMP32]], align 1
; CHECK-NEXT:    br label [[TMP38:%.*]]
; CHECK:       37:
; CHECK-NEXT:    store i8 [[VAL_FCA_EXTRACT_3]], i8 addrspace(21)* [[TMP31]], align 1
; CHECK-NEXT:    br label [[TMP38]]
; CHECK:       38:
; CHECK-NEXT:    ret i32 [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  store i32 %val, i32* %addr, align 2
  ret i32 %val
}

define %complex_type @load_struct_reg() {
; CHECK-LABEL: @load_struct_reg(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 11) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP2]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load %complex_type*, %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE:%.*]] poison, %complex_type* [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP3:%.*]] = load half, half addrspace(20)* addrspacecast (half* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 12) to half*) to half addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP3]], 1
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 13) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP4]], 0
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP5]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load [[COMPLEX_TYPE]] addrspace(1)*, [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @load_struct_mem() {
; CHECK-LABEL: @load_struct_mem(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 15
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to [[COMPLEX_TYPE:%.*]] addrspace(21)*
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast %complex_type* addrspace(21)* [[TMP7]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 0
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, i32 addrspace(21)* [[TMP9]], align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP10]], 0
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 1
; CHECK-NEXT:    [[TMP12:%.*]] = load i32, i32 addrspace(21)* [[TMP11]], align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP12]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load %complex_type*, %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] poison, %complex_type* [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[TMP14:%.*]] = load half, half addrspace(21)* [[TMP13]], align 4
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP14]], 1
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[TMP16:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)* addrspace(21)* [[TMP15]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP16]], i32 0, i32 0
; CHECK-NEXT:    [[TMP18:%.*]] = load i32, i32 addrspace(21)* [[TMP17]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP18]], 0
; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP16]], i32 0, i32 1
; CHECK-NEXT:    [[TMP20:%.*]] = load i32, i32 addrspace(21)* [[TMP19]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP20]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load [[COMPLEX_TYPE]] addrspace(1)*, [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @load_struct_both() {
; CHECK-LABEL: @load_struct_both(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 13
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to [[COMPLEX_TYPE:%.*]] addrspace(21)*
; CHECK-NEXT:    [[TMP7:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 13) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP7]], 0
; CHECK-NEXT:    [[TMP8:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP8]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load %complex_type*, %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] poison, %complex_type* [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[TMP10:%.*]] = load half, half addrspace(21)* [[TMP9]], align 4
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP10]], 1
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)* addrspace(21)* [[TMP11]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP12]], i32 0, i32 0
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, i32 addrspace(21)* [[TMP13]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP14]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP12]], i32 0, i32 1
; CHECK-NEXT:    [[TMP16:%.*]] = load i32, i32 addrspace(21)* [[TMP15]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP16]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load [[COMPLEX_TYPE]] addrspace(1)*, [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 13
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @load_struct_dyn(i32 %i) {
; CHECK-LABEL: @load_struct_dyn(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 [[I:%.*]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], [20 x i32]* addrspacecast ([20 x i32] addrspace(20)* bitcast ([15 x i32] addrspace(20)* @GLOBAL to [20 x i32] addrspace(20)*) to [20 x i32]*), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to [[COMPLEX_TYPE:%.*]] addrspace(21)*
; CHECK-NEXT:    [[ADDR_TYPE:%.*]] = bitcast i32* [[ADDR]] to %complex_type*
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], %complex_type* [[ADDR_TYPE]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast %complex_type* addrspace(21)* [[TMP7]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_0_PTR:%.*]] = bitcast %complex_type** [[VAL_FCA_0_GEP]] to <{ i32, i32 }>*
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_GEP_0:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_PTR]], i32 0, i32 0
; CHECK-NEXT:    [[TMP10:%.*]] = addrspacecast i32* [[VAL_FCA_0_GEP_0]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP11:%.*]] = ptrtoint i32 addrspace(20)* [[TMP10]] to i32
; CHECK-NEXT:    [[TMP12:%.*]] = sub i32 [[TMP11]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP13:%.*]] = icmp ult i32 [[TMP12]], 60
; CHECK-NEXT:    br i1 [[TMP13]], label [[TMP14:%.*]], label [[TMP16:%.*]]
; CHECK:       14:
; CHECK-NEXT:    [[TMP15:%.*]] = load i32, i32 addrspace(20)* [[TMP10]], align 4
; CHECK-NEXT:    br label [[TMP18:%.*]]
; CHECK:       16:
; CHECK-NEXT:    [[TMP17:%.*]] = load i32, i32 addrspace(21)* [[TMP9]], align 4
; CHECK-NEXT:    br label [[TMP18]]
; CHECK:       18:
; CHECK-NEXT:    [[TMP19:%.*]] = phi i32 [ [[TMP15]], [[TMP14]] ], [ [[TMP17]], [[TMP16]] ]
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP19]], 0
; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_PTR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP21:%.*]] = addrspacecast i32* [[VAL_FCA_0_GEP_1]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP22:%.*]] = ptrtoint i32 addrspace(20)* [[TMP21]] to i32
; CHECK-NEXT:    [[TMP23:%.*]] = sub i32 [[TMP22]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP24:%.*]] = icmp ult i32 [[TMP23]], 60
; CHECK-NEXT:    br i1 [[TMP24]], label [[TMP25:%.*]], label [[TMP27:%.*]]
; CHECK:       25:
; CHECK-NEXT:    [[TMP26:%.*]] = load i32, i32 addrspace(20)* [[TMP21]], align 4
; CHECK-NEXT:    br label [[TMP29:%.*]]
; CHECK:       27:
; CHECK-NEXT:    [[TMP28:%.*]] = load i32, i32 addrspace(21)* [[TMP20]], align 4
; CHECK-NEXT:    br label [[TMP29]]
; CHECK:       29:
; CHECK-NEXT:    [[TMP30:%.*]] = phi i32 [ [[TMP26]], [[TMP25]] ], [ [[TMP28]], [[TMP27]] ]
; CHECK-NEXT:    [[VAL_FCA_0_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_0_INSERT_0]], i32 [[TMP30]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_0_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load %complex_type*, %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] poison, %complex_type* [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], %complex_type* [[ADDR_TYPE]], i32 0, i32 1
; CHECK-NEXT:    [[TMP32:%.*]] = addrspacecast half* [[VAL_FCA_1_GEP]] to half addrspace(20)*
; CHECK-NEXT:    [[TMP33:%.*]] = ptrtoint half addrspace(20)* [[TMP32]] to i32
; CHECK-NEXT:    [[TMP34:%.*]] = sub i32 [[TMP33]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP35:%.*]] = icmp ult i32 [[TMP34]], 60
; CHECK-NEXT:    br i1 [[TMP35]], label [[TMP36:%.*]], label [[TMP38:%.*]]
; CHECK:       36:
; CHECK-NEXT:    [[TMP37:%.*]] = load half, half addrspace(20)* [[TMP32]], align 4
; CHECK-NEXT:    br label [[TMP40:%.*]]
; CHECK:       38:
; CHECK-NEXT:    [[TMP39:%.*]] = load half, half addrspace(21)* [[TMP31]], align 4
; CHECK-NEXT:    br label [[TMP40]]
; CHECK:       40:
; CHECK-NEXT:    [[TMP41:%.*]] = phi half [ [[TMP37]], [[TMP36]] ], [ [[TMP39]], [[TMP38]] ]
; CHECK-NEXT:    [[VAL_FCA_1_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_0_INSERT]], half [[TMP41]], 1
; CHECK-NEXT:    [[TMP42:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], %complex_type* [[ADDR_TYPE]], i32 0, i32 2
; CHECK-NEXT:    [[TMP43:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)* addrspace(21)* [[TMP42]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_2_PTR:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_GEP]] to <{ i32, i32 }>*
; CHECK-NEXT:    [[TMP44:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP43]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_2_GEP_0:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_PTR]], i32 0, i32 0
; CHECK-NEXT:    [[TMP45:%.*]] = addrspacecast i32* [[VAL_FCA_2_GEP_0]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP46:%.*]] = ptrtoint i32 addrspace(20)* [[TMP45]] to i32
; CHECK-NEXT:    [[TMP47:%.*]] = sub i32 [[TMP46]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP48:%.*]] = icmp ult i32 [[TMP47]], 60
; CHECK-NEXT:    br i1 [[TMP48]], label [[TMP49:%.*]], label [[TMP51:%.*]]
; CHECK:       49:
; CHECK-NEXT:    [[TMP50:%.*]] = load i32, i32 addrspace(20)* [[TMP45]], align 4
; CHECK-NEXT:    br label [[TMP53:%.*]]
; CHECK:       51:
; CHECK-NEXT:    [[TMP52:%.*]] = load i32, i32 addrspace(21)* [[TMP44]], align 4
; CHECK-NEXT:    br label [[TMP53]]
; CHECK:       53:
; CHECK-NEXT:    [[TMP54:%.*]] = phi i32 [ [[TMP50]], [[TMP49]] ], [ [[TMP52]], [[TMP51]] ]
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_0:%.*]] = insertvalue <{ i32, i32 }> poison, i32 [[TMP54]], 0
; CHECK-NEXT:    [[TMP55:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP43]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_PTR]], i32 0, i32 1
; CHECK-NEXT:    [[TMP56:%.*]] = addrspacecast i32* [[VAL_FCA_2_GEP_1]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP57:%.*]] = ptrtoint i32 addrspace(20)* [[TMP56]] to i32
; CHECK-NEXT:    [[TMP58:%.*]] = sub i32 [[TMP57]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP59:%.*]] = icmp ult i32 [[TMP58]], 60
; CHECK-NEXT:    br i1 [[TMP59]], label [[TMP60:%.*]], label [[TMP62:%.*]]
; CHECK:       60:
; CHECK-NEXT:    [[TMP61:%.*]] = load i32, i32 addrspace(20)* [[TMP56]], align 4
; CHECK-NEXT:    br label [[TMP64:%.*]]
; CHECK:       62:
; CHECK-NEXT:    [[TMP63:%.*]] = load i32, i32 addrspace(21)* [[TMP55]], align 4
; CHECK-NEXT:    br label [[TMP64]]
; CHECK:       64:
; CHECK-NEXT:    [[TMP65:%.*]] = phi i32 [ [[TMP61]], [[TMP60]] ], [ [[TMP63]], [[TMP62]] ]
; CHECK-NEXT:    [[VAL_FCA_2_INSERT_1:%.*]] = insertvalue <{ i32, i32 }> [[VAL_FCA_2_INSERT_0]], i32 [[TMP65]], 1
; CHECK-NEXT:    store <{ i32, i32 }> [[VAL_FCA_2_INSERT_1]], <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load [[COMPLEX_TYPE]] addrspace(1)*, [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_INSERT:%.*]] = insertvalue [[COMPLEX_TYPE]] [[VAL_FCA_1_INSERT]], [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_ALLOCA_LOAD]], 2
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL_FCA_2_INSERT]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %addr_type = bitcast i32* %addr to %complex_type*
  %val = load %complex_type, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_reg(%complex_type %val) {
; CHECK-LABEL: @store_struct_reg(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE:%.*]] [[VAL:%.*]], 0
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    store %complex_type* [[VAL_FCA_0_EXTRACT]], %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 11) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], half addrspace(20)* addrspacecast (half* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 12) to half*) to half addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    store [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_EXTRACT]], [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 13) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_mem(%complex_type %val) {
; CHECK-LABEL: @store_struct_mem(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 15
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to [[COMPLEX_TYPE:%.*]] addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL:%.*]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast %complex_type* addrspace(21)* [[TMP7]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    store %complex_type* [[VAL_FCA_0_EXTRACT]], %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], i32 addrspace(21)* [[TMP9]], align 4
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], i32 addrspace(21)* [[TMP10]], align 4
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], half addrspace(21)* [[TMP11]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)* addrspace(21)* [[TMP12]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    store [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_EXTRACT]], [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP13]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], i32 addrspace(21)* [[TMP14]], align 4
; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP13]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], i32 addrspace(21)* [[TMP15]], align 4
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 15
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_both(%complex_type %val) {
; CHECK-LABEL: @store_struct_both(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 13
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to [[COMPLEX_TYPE:%.*]] addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL:%.*]], 0
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    store %complex_type* [[VAL_FCA_0_EXTRACT]], %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 13) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 14) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], half addrspace(21)* [[TMP7]], align 4
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)* addrspace(21)* [[TMP8]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    store [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_EXTRACT]], [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP9]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], i32 addrspace(21)* [[TMP10]], align 4
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP9]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], i32 addrspace(21)* [[TMP11]], align 4
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 13
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define %complex_type @store_struct_dyn(%complex_type %val, i32 %i) {
; CHECK-LABEL: @store_struct_dyn(
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA:%.*]] = alloca <{ i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = call i32 addrspace(21)* @registerbuffer.getpointer.a15i32([15 x i32] addrspace(20)* @GLOBAL)
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr i32, i32 addrspace(21)* [[TMP1]], i32 -15
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(21)* [[TMP2]] to [15 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast [15 x i32] addrspace(21)* [[TMP3]] to [20 x i32] addrspace(21)*
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [20 x i32], [20 x i32] addrspace(21)* [[TMP4]], i32 0, i32 [[I:%.*]]
; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr [20 x i32], [20 x i32]* addrspacecast ([20 x i32] addrspace(20)* bitcast ([15 x i32] addrspace(20)* @GLOBAL to [20 x i32] addrspace(20)*) to [20 x i32]*), i32 0, i32 [[I]]
; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i32 addrspace(21)* [[TMP5]] to [[COMPLEX_TYPE:%.*]] addrspace(21)*
; CHECK-NEXT:    [[ADDR_TYPE:%.*]] = bitcast i32* [[ADDR]] to %complex_type*
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL:%.*]], 0
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], %complex_type* [[ADDR_TYPE]], i32 0, i32 0
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast %complex_type* addrspace(21)* [[TMP7]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_0_PTR:%.*]] = bitcast %complex_type** [[VAL_FCA_0_GEP]] to <{ i32, i32 }>*
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]] to %complex_type**
; CHECK-NEXT:    store %complex_type* [[VAL_FCA_0_EXTRACT]], %complex_type** [[VAL_FCA_0_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_0_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_ALLOCA]], align 1
; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_GEP_0:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_PTR]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP10:%.*]] = addrspacecast i32* [[VAL_FCA_0_GEP_0]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP11:%.*]] = ptrtoint i32 addrspace(20)* [[TMP10]] to i32
; CHECK-NEXT:    [[TMP12:%.*]] = sub i32 [[TMP11]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP13:%.*]] = icmp ult i32 [[TMP12]], 60
; CHECK-NEXT:    br i1 [[TMP13]], label [[TMP14:%.*]], label [[TMP15:%.*]]
; CHECK:       14:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], i32 addrspace(20)* [[TMP10]], align 4
; CHECK-NEXT:    br label [[TMP16:%.*]]
; CHECK:       15:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_0]], i32 addrspace(21)* [[TMP9]], align 4
; CHECK-NEXT:    br label [[TMP16]]
; CHECK:       16:
; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP8]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_0_PTR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_0_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_0_ALLOCA_LOAD]], 1
; CHECK-NEXT:    [[TMP18:%.*]] = addrspacecast i32* [[VAL_FCA_0_GEP_1]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP19:%.*]] = ptrtoint i32 addrspace(20)* [[TMP18]] to i32
; CHECK-NEXT:    [[TMP20:%.*]] = sub i32 [[TMP19]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP21:%.*]] = icmp ult i32 [[TMP20]], 60
; CHECK-NEXT:    br i1 [[TMP21]], label [[TMP22:%.*]], label [[TMP23:%.*]]
; CHECK:       22:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], i32 addrspace(20)* [[TMP18]], align 4
; CHECK-NEXT:    br label [[TMP24:%.*]]
; CHECK:       23:
; CHECK-NEXT:    store i32 [[VAL_FCA_0_EXTRACT_1]], i32 addrspace(21)* [[TMP17]], align 4
; CHECK-NEXT:    br label [[TMP24]]
; CHECK:       24:
; CHECK-NEXT:    [[VAL_FCA_1_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 1
; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_1_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], %complex_type* [[ADDR_TYPE]], i32 0, i32 1
; CHECK-NEXT:    [[TMP26:%.*]] = addrspacecast half* [[VAL_FCA_1_GEP]] to half addrspace(20)*
; CHECK-NEXT:    [[TMP27:%.*]] = ptrtoint half addrspace(20)* [[TMP26]] to i32
; CHECK-NEXT:    [[TMP28:%.*]] = sub i32 [[TMP27]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP29:%.*]] = icmp ult i32 [[TMP28]], 60
; CHECK-NEXT:    br i1 [[TMP29]], label [[TMP30:%.*]], label [[TMP31:%.*]]
; CHECK:       30:
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], half addrspace(20)* [[TMP26]], align 4
; CHECK-NEXT:    br label [[TMP32:%.*]]
; CHECK:       31:
; CHECK-NEXT:    store half [[VAL_FCA_1_EXTRACT]], half addrspace(21)* [[TMP25]], align 4
; CHECK-NEXT:    br label [[TMP32]]
; CHECK:       32:
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT:%.*]] = extractvalue [[COMPLEX_TYPE]] [[VAL]], 2
; CHECK-NEXT:    [[TMP33:%.*]] = getelementptr [[COMPLEX_TYPE]], [[COMPLEX_TYPE]] addrspace(21)* [[TMP6]], i32 0, i32 2
; CHECK-NEXT:    [[VAL_FCA_2_GEP:%.*]] = getelementptr inbounds [[COMPLEX_TYPE]], %complex_type* [[ADDR_TYPE]], i32 0, i32 2
; CHECK-NEXT:    [[TMP34:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)* addrspace(21)* [[TMP33]] to <{ i32, i32 }> addrspace(21)*
; CHECK-NEXT:    [[VAL_FCA_2_PTR:%.*]] = bitcast [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_GEP]] to <{ i32, i32 }>*
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]] to [[COMPLEX_TYPE]] addrspace(1)**
; CHECK-NEXT:    store [[COMPLEX_TYPE]] addrspace(1)* [[VAL_FCA_2_EXTRACT]], [[COMPLEX_TYPE]] addrspace(1)** [[VAL_FCA_2_ALLOCA_CAST]], align 8
; CHECK-NEXT:    [[VAL_FCA_2_ALLOCA_LOAD:%.*]] = load <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_ALLOCA]], align 1
; CHECK-NEXT:    [[TMP35:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP34]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_2_GEP_0:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_PTR]], i32 0, i32 0
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_0:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 0
; CHECK-NEXT:    [[TMP36:%.*]] = addrspacecast i32* [[VAL_FCA_2_GEP_0]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP37:%.*]] = ptrtoint i32 addrspace(20)* [[TMP36]] to i32
; CHECK-NEXT:    [[TMP38:%.*]] = sub i32 [[TMP37]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP39:%.*]] = icmp ult i32 [[TMP38]], 60
; CHECK-NEXT:    br i1 [[TMP39]], label [[TMP40:%.*]], label [[TMP41:%.*]]
; CHECK:       40:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], i32 addrspace(20)* [[TMP36]], align 4
; CHECK-NEXT:    br label [[TMP42:%.*]]
; CHECK:       41:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_0]], i32 addrspace(21)* [[TMP35]], align 4
; CHECK-NEXT:    br label [[TMP42]]
; CHECK:       42:
; CHECK-NEXT:    [[TMP43:%.*]] = getelementptr <{ i32, i32 }>, <{ i32, i32 }> addrspace(21)* [[TMP34]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_GEP_1:%.*]] = getelementptr inbounds <{ i32, i32 }>, <{ i32, i32 }>* [[VAL_FCA_2_PTR]], i32 0, i32 1
; CHECK-NEXT:    [[VAL_FCA_2_EXTRACT_1:%.*]] = extractvalue <{ i32, i32 }> [[VAL_FCA_2_ALLOCA_LOAD]], 1
; CHECK-NEXT:    [[TMP44:%.*]] = addrspacecast i32* [[VAL_FCA_2_GEP_1]] to i32 addrspace(20)*
; CHECK-NEXT:    [[TMP45:%.*]] = ptrtoint i32 addrspace(20)* [[TMP44]] to i32
; CHECK-NEXT:    [[TMP46:%.*]] = sub i32 [[TMP45]], ptrtoint ([15 x i32] addrspace(20)* @GLOBAL to i32)
; CHECK-NEXT:    [[TMP47:%.*]] = icmp ult i32 [[TMP46]], 60
; CHECK-NEXT:    br i1 [[TMP47]], label [[TMP48:%.*]], label [[TMP49:%.*]]
; CHECK:       48:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], i32 addrspace(20)* [[TMP44]], align 4
; CHECK-NEXT:    br label [[TMP50:%.*]]
; CHECK:       49:
; CHECK-NEXT:    store i32 [[VAL_FCA_2_EXTRACT_1]], i32 addrspace(21)* [[TMP43]], align 4
; CHECK-NEXT:    br label [[TMP50]]
; CHECK:       50:
; CHECK-NEXT:    ret [[COMPLEX_TYPE]] [[VAL]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 %i
  %addr_type = bitcast i32* %addr to %complex_type*
  store %complex_type %val, %complex_type* %addr_type
  ret %complex_type %val
}

define <3 x float> @load_v3float_reg() {
; CHECK-LABEL: @load_v3float_reg(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i32, i32 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i32, i32 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 11) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i32, i32 }> [[VAL_FCA_INSERT_0]], i32 [[TMP2]], 1
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 12) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_2:%.*]] = insertvalue <{ i32, i32, i32 }> [[VAL_FCA_INSERT_1]], i32 [[TMP3]], 2
; CHECK-NEXT:    store <{ i32, i32, i32 }> [[VAL_FCA_INSERT_2]], <{ i32, i32, i32 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i32, i32, i32 }>* [[VAL_FCA_ALLOCA]] to <3 x float>*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <3 x float>, <3 x float>* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret <3 x float> [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to <3 x float>*
  %val = load <3 x float>, <3 x float>* %addr_type
  ret <3 x float> %val
}

define <3 x half> @load_v3half_reg() {
; CHECK-LABEL: @load_v3half_reg(
; CHECK-NEXT:    [[VAL_FCA_ALLOCA:%.*]] = alloca <{ i32, i16 }>, align 8
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(20)* addrspacecast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to i32 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_0:%.*]] = insertvalue <{ i32, i16 }> poison, i32 [[TMP1]], 0
; CHECK-NEXT:    [[TMP2:%.*]] = load i16, i16 addrspace(20)* addrspacecast (i16* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 11) to i16*) to i16 addrspace(20)*), align 4
; CHECK-NEXT:    [[VAL_FCA_INSERT_1:%.*]] = insertvalue <{ i32, i16 }> [[VAL_FCA_INSERT_0]], i16 [[TMP2]], 1
; CHECK-NEXT:    store <{ i32, i16 }> [[VAL_FCA_INSERT_1]], <{ i32, i16 }>* [[VAL_FCA_ALLOCA]], align 1
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_CAST:%.*]] = bitcast <{ i32, i16 }>* [[VAL_FCA_ALLOCA]] to <3 x half>*
; CHECK-NEXT:    [[VAL_FCA_ALLOCA_LOAD:%.*]] = load <3 x half>, <3 x half>* [[VAL_FCA_ALLOCA_CAST]], align 8
; CHECK-NEXT:    ret <3 x half> [[VAL_FCA_ALLOCA_LOAD]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to <3 x half>*
  %val = load <3 x half>, <3 x half>* %addr_type
  ret <3 x half> %val
}

define <3 x i8> @load_v3i8_reg() {
; CHECK-LABEL: @load_v3i8_reg(
; CHECK-NEXT:    [[TMP1:%.*]] = load <3 x i8>, <3 x i8> addrspace(20)* addrspacecast (<3 x i8>* bitcast (i32* getelementptr ([15 x i32], [15 x i32]* addrspacecast ([15 x i32] addrspace(20)* @GLOBAL to [15 x i32]*), i64 0, i64 10) to <3 x i8>*) to <3 x i8> addrspace(20)*), align 4
; CHECK-NEXT:    ret <3 x i8> [[TMP1]]
;
  %addr = getelementptr [20 x i32], [20 x i32]* @GLOBAL, i32 0, i32 10
  %addr_type = bitcast i32* %addr to <3 x i8>*
  %val = load <3 x i8>, <3 x i8>* %addr_type
  ret <3 x i8> %val
}

define void @with_lifetime_intrinsics() {
; CHECK-LABEL: @with_lifetime_intrinsics(
; CHECK-NEXT:    ret void
;
  %ptr = bitcast [20 x i32]* @GLOBAL to i8*
  call void @llvm.lifetime.start.p0i8(i64 80, i8* %ptr)
  call void @llvm.lifetime.end.p0i8(i64 80, i8* %ptr)
  ret void
}
