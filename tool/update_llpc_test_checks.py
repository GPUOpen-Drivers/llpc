#!/usr/bin/env python3

# This script is based on the LLVM Project's update_test_checks.py, which is
# licensed under the Apache License v2.0 with LLVM Exceptions; see the file
# UpdateTestChecks/LICENSE.txt relative to this directory. It has been heavily
# modified for use with LLPC.

"""Generate FileCheck statements for LLPC lit tests.

This tool is designed to be used on LLPC lit tests that are configured to
output a single batch of intermediate IR, for example, using the -emit-lgc
option.

Example usage:

# Default to using `amdllpc` as found in your PATH.
$ update_llpc_test_checks.py llpc/test/foo.comp

# Override the lookup of amdllpc.
$ update_llpc_test_checks.py --tool-binary=../../../build/dbg/compiler/llpc/amdllpc llpc/test/foo.comp
"""

import argparse
import os  # Used to advertise this file's name ("autogenerated_note").
import re
import sys

from UpdateTestChecks import common

def main():
  from argparse import RawTextHelpFormatter
  parser = argparse.ArgumentParser(description=__doc__, formatter_class=RawTextHelpFormatter)
  parser.add_argument('--tool', default='amdllpc',
                      help='The name of the tool used to generate the test case (defaults to "amdllpc")')
  parser.add_argument('--tool-binary',
                      help='The tool binary used to generate the test case')
  parser.add_argument('-p', '--preserve-names', action='store_true',
                      help='Do not scrub IR names')
  parser.add_argument('--function-signature', action='store_true',
                      help='Keep function signature information around for the check line')
  parser.add_argument('--scrub-attributes', action='store_true',
                      help='Remove attribute annotations (#0) from the end of check line')
  parser.add_argument('--check-attributes', action='store_true',
                      help='Check "Function Attributes" for functions')
  parser.add_argument('--check-globals', action='store_true',
                      help='Check global entries (global variables, metadata, attribute sets, ...) for functions')
  parser.add_argument('tests', nargs='+')
  initial_args = common.parse_commandline_args(parser)

  if initial_args.tool_binary:
    tool_basename = os.path.basename(initial_args.tool_binary)
    if not re.match(r'^%s(-\d+)?(\.exe)?$' % (initial_args.tool), tool_basename):
      common.error('Unexpected tool name: ' + tool_basename)
      sys.exit(1)
  tool_basename = initial_args.tool

  for ti in common.itertests(initial_args.tests, parser, 'tool/update_llpc_test_checks.py',
                             comment_prefix='//'):
    # If requested we scrub trailing attribute annotations, e.g., '#0', together with whitespaces
    if ti.args.scrub_attributes:
      common.SCRUB_TRAILING_WHITESPACE_TEST_RE = common.SCRUB_TRAILING_WHITESPACE_AND_ATTRIBUTES_RE
    else:
      common.SCRUB_TRAILING_WHITESPACE_TEST_RE = common.SCRUB_TRAILING_WHITESPACE_RE

    prefix_list = []
    for l in ti.run_lines:
      if '|' not in l:
        common.warn('Skipping unparsable RUN line: ' + l)
        continue

      commands = [cmd.strip() for cmd in l.split('|')]
      assert len(commands) >= 2
      if len(commands) > 2:
        common.error('Complex pipes are unsupported')
        sys.exit(1)
      tool_cmd = commands[-2]
      filecheck_cmd = commands[-1]
      common.verify_filecheck_prefixes(filecheck_cmd)
      if not tool_cmd.startswith(tool_basename + ' '):
        common.warn('Skipping non-%s RUN line: %s' % (tool_basename, l))
        continue

      if not filecheck_cmd.startswith('FileCheck '):
        common.warn('Skipping non-FileChecked RUN line: ' + l)
        continue

      tool_cmd_args = tool_cmd[len(tool_basename):].strip()

      check_prefixes = [item for m in
                        common.CHECK_PREFIX_RE.finditer(filecheck_cmd)
                        for item in m.group(1).split(',')]
      if not check_prefixes:
        check_prefixes = ['CHECK']

      # FIXME: We should use multiple check prefixes to common check lines. For
      # now, we just ignore all but the last.
      prefix_list.append((check_prefixes, tool_cmd_args))

    global_vars_seen_dict = {}
    builder = common.FunctionTestBuilder(
      run_list=prefix_list,
      flags=ti.args,
      scrubber_args=[],
      path=ti.path)

    tool_binary = ti.args.tool_binary
    if not tool_binary:
      tool_binary = tool_basename

    for prefixes, tool_args in prefix_list:
      common.debug('Extracted tool cmd: ' + tool_basename + ' ' + tool_args)
      common.debug('Extracted FileCheck prefixes: ' + str(prefixes))

      raw_tool_output = common.invoke_tool_only(tool_binary, tool_args, ti.path,
                                                verbose=ti.args.verbose)
      builder.process_run_line(common.OPT_FUNCTION_RE, common.scrub_body,
              raw_tool_output, prefixes, False)
      builder.processed_prefixes(prefixes)

    func_dict = builder.finish_and_get_func_dict()
    is_in_function = False
    is_in_function_start = False
    has_checked_pre_function_globals = False
    prefix_set = set([prefix for prefixes, _ in prefix_list for prefix in prefixes])
    common.debug('Rewriting FileCheck prefixes:', str(prefix_set))
    output_lines = []

    # Generate the appropriate checks for each function.  We need to emit
    # these in the order according to the generated output so that CHECK-LABEL
    # works properly.  func_order provides that.

    # We can't predict where various passes might insert functions so we can't
    # be sure the input function order is maintained.  Therefore, first spit
    # out all the source lines.
    common.dump_input_lines(output_lines, ti, prefix_set, ti.comment_prefix)

    args = ti.args
    if args.check_globals:
        common.add_global_checks(builder.global_var_dict(), ti.comment_prefix,
                                 prefix_list, output_lines, global_vars_seen_dict,
                                 args.preserve_names, True)

    # Now generate all the checks.
    common.add_checks_at_end(output_lines, prefix_list, builder.func_order(),
                              ti.comment_prefix, lambda my_output_lines, prefixes, func:
                              common.add_ir_checks(my_output_lines, ti.comment_prefix,
                                                  prefixes,
                                                  func_dict, func, False,
                                                  args.function_signature,
                                                  global_vars_seen_dict,
                                                  is_filtered=builder.is_filtered()))

    if args.check_globals:
        common.add_global_checks(builder.global_var_dict(), ti.comment_prefix,
                                 prefix_list, output_lines, global_vars_seen_dict,
                                 args.preserve_names, False)
    common.debug('Writing %d lines to %s...' % (len(output_lines), ti.path))

    with open(ti.path, 'wb') as f:
      f.writelines(['{}\n'.format(l).encode('utf-8') for l in output_lines])


if __name__ == '__main__':
  main()
